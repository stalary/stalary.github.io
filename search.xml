<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[MySQL分页排序中的坑]]></title>
      <url>/2018/06/04/MySQL%E5%88%86%E9%A1%B5%E6%8E%92%E5%BA%8F%E4%B8%AD%E7%9A%84%E5%9D%91/</url>
      <content type="html"><![CDATA[<p>今天项目提测，被测出了一个奇怪的bug，第一页最后一条数据和第二页的第一条数据重复了，并且神奇的丢失了一个条数据，下面开始来分析一下这个场景。</p>
<blockquote>
<p>场景为对一些作业进行按时间排序，但是有的作业时间事相同的。</p>
</blockquote>
<p>对代码进行查看发现，代码并没有什么问题，只是简单的查询全集并按时间排序分页返回给前端。</p>
<p>所以去看一看mysql对limit的解释，从官方文档中发现了这样一句话</p>
<blockquote>
<p>如果多个行在列中具有相同的值ORDER BY，则服务器可以按任意顺序自由返回这些行，并且根据总体执行计划可能会有所不同。换句话说，这些行的排序顺序对于无序列是非确定性的。</p>
</blockquote>
<p>根据这句话我们可以发现，在order by的值相同时，返回的顺序不一定一致。</p>
<p>下面我们来思考一下造成这个坑的原因是什么呢？</p>
<p>在MySQL 5.6版本，优化器在遇到order by xxx limit x,x 时，会做一个优化，使用优先队列，来进行排序，这样的好处在于在排序过程中，仅保留需要的n条数据即可。</p>
<p>如果你已经熟悉了各大排序的特点，那么可以知道堆排序是不稳定排序，所以导致了今天的这个问题。</p>
<p>下面分享一下各个排序的稳定性：</p>
<blockquote>
<ol>
<li>冒泡排序：稳定</li>
<li>选择排序：不稳定，每次选择最小的与之前交换，可能会将相同元素的顺序打乱</li>
<li>插入排序：稳定</li>
<li>快速排序：不稳定，不稳定发生在key与相遇点进行交换时。</li>
<li>归并排序：稳定</li>
<li>基数排序：稳定</li>
<li>希尔排序：不稳定，插入顺序不同，相同元素可能在不同的插入顺序中分别排序</li>
<li>堆排序：不稳定，可能子节点与父节点进行交换时，将两个相同元素顺序打乱，5(left) 6(root) 5(right) -&gt; 5 5 6，此时right位于5的left</li>
</ol>
</blockquote>
<p>下面说一下问题的解决方法：</p>
<blockquote>
<ol>
<li>order by后加一个唯一字段(id)进行排序</li>
<li>给order by字段加上索引</li>
</ol>
</blockquote>
]]></content>
      
        <categories>
            
            <category> mysql </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[kafka集群的崩溃以及配置]]></title>
      <url>/2018/05/30/kafkacluster/</url>
      <content type="html"><![CDATA[<p>今天由于kafka集群搭建时的配置不当，由于一台主消费者挂掉(服务器崩了，需要维修)，导致了所有新版消费者(新版的offset存储在kafka)都无法拉取消息。</p>
<p>由于是线上问题，所以是绝对不能影响用户的，使用老版客户端(offset存储在zk)进行消费，然后将kafka迁移到备用服务。</p>
<p>下面来说一下这次事故的具体处理思路</p>
<ol>
<li>首先要确保获取到的消息不能丢失，所以老版消费者进行消费</li>
<li>线上服务通过均衡负载一台一台的进行切换kafka服务，当原生产者数据都消费完时，将消费者切换到备用服务</li>
<li>开始配置线上kafka服务</li>
</ol>
<p>主要做了如下修改</p>
<blockquote>
<p>offsets.topic.replication.factor=3</p>
</blockquote>
<p>设置副本数量为3,这样当一台消费者宕机时，其他消费者也可以进行消费</p>
<p>为了使topic可以进行复制副本，这里采用了比较粗暴的方法，直接清空topic和offset<br>分为以下几个步骤</p>
<blockquote>
<p>./zookeeper-shell.sh 127.0.0.1:24500<br>rmr  /brokers/topics/topic-name<br>rmr  /config/topics/topic-name<br>rmr /admin/delete_topics/topic-name</p>
</blockquote>
<p>此时已经将topic完全删除，然后进行topic的新建</p>
<blockquote>
<p>bin/kafka-topics –create –zookeeper localhost:2181 –replication-factor 3 –partitions 3 –topic topic-name</p>
</blockquote>
<p>这时可以启动生产者和消费者进行查看，已经不再出现一开始的异常</p>
<blockquote>
<p>Connection to node -1 could not be established. Broker may not be available.</p>
</blockquote>
<p>这时我进行了测试，对三台broker中的任意一台进行下线，服务会自动选择其他节点进行生产和消费。</p>
<p><strong>只要自己能做，就不要交给别人，只有自己才是最靠得住的</strong></p>
]]></content>
      
        <categories>
            
            <category> kafka </category>
            
        </categories>
        
        
        <tags>
            
            <tag> kafka </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python与java读取api的对比]]></title>
      <url>/2018/05/29/spider/</url>
      <content type="html"><![CDATA[<p>今天来说一下为什么我们一般会选择python来作为爬虫</p>
<p>我们来对可以直接获取到api来进行抓取数据的情况来分析</p>
<p>例如我要爬取一个博客<br>如果用java来解析代码需要这样写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String s = httpJsonGet(<span class="string">"http://47.94.17.80:8100/news/newsList?size=10&amp;index=1"</span>);</span><br><span class="line">    ObjectMapper jackson = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    JsonNode data = jackson.readTree(s).get(<span class="string">"data"</span>);</span><br><span class="line">    JsonNode newsAndCommentList = data.get(<span class="string">"newsAndCommentList"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; newsAndCommentList.size(); i++) &#123;</span><br><span class="line">        JsonNode newsAndComment = newsAndCommentList.get(i);</span><br><span class="line">        JsonNode newsDTO = newsAndComment.get(<span class="string">"newsDTO"</span>);</span><br><span class="line">        JsonNode commentDTOList = newsAndComment.get(<span class="string">"commentDTOList"</span>);</span><br><span class="line">        System.out.println(newsDTO);</span><br><span class="line">        System.out.println(commentDTOList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用python需要这样写</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">res = requests.get(<span class="string">'http://47.94.17.80:8100/news/newsList?size=10&amp;index=1'</span>).json()</span><br><span class="line">data = res[<span class="string">'data'</span>][<span class="string">'newsAndCommentList'</span>]</span><br><span class="line"><span class="keyword">for</span> dto <span class="keyword">in</span> data:</span><br><span class="line">    print(index)</span><br><span class="line">    print(<span class="string">'news: '</span> + str(dto[<span class="string">'newsDTO'</span>]))</span><br><span class="line">    print(<span class="string">'comment: '</span> + str(dto[<span class="string">'commentDTOList'</span>]))</span><br></pre></td></tr></table></figure>
<p>使用java时，需要自己封装一下httpclient，并且还要引入json解析的包，当使用python时，我们需要引入一下requests即可，并且从代码量也可以看出，python还是很占优势的。</p>
<p><strong>一切的坚持，都源自于兴趣</strong></p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【java】如何对Map的值进行排序]]></title>
      <url>/2018/05/15/sortByValue/</url>
      <content type="html"><![CDATA[<p>在项目中总会遇到要对数据进行排序的情况，当我们使用HashMap时，如果对键排序，十分方便，可以直接使用TreeMap，但是如果对值排序，我们就需要做一些事情了。</p>
<p>这里我们举一个最简单的例子，要把HashMap按照出现的次数进行排序</p>
<p>首先存入元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;</span><br><span class="line">                <span class="number">4</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">    map.put(i, map.getOrDefault(i, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出-1和2出现了2次，下面我们进行排序操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Map.Entry&lt;Integer, Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(map.entrySet());</span><br><span class="line">list.sort((o1, o2) -&gt; o2.getValue().compareTo(o1.getValue()));</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>[-1=2, 2=2, 1=1, 3=1, 4=1]</p>
</blockquote>
<p>可以看出map已经排好顺序了，如果需要输出一个map，那么我们可以这样操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; result = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">list.forEach(entity -&gt; result.put(entity.getKey(), entity.getValue()));</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>{-1=2, 2=2, 1=1, 3=1, 4=1}</p>
</blockquote>
<p>对HashMap值的排序就介绍到这里了，如有问题请联系博主。</p>
<p><strong>一份热爱，一份坚持</strong></p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
            <category> 集合 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【web】海量数据的简单清洗]]></title>
      <url>/2018/05/09/dataclean/</url>
      <content type="html"><![CDATA[<p>这周接到了一个对爬取数据进行清理的任务，具体需求为，有一张接近百万的key值表，每一个key对应一个对象，但是在es中存在大量的相似对象，需要按照相似度清除key值表中重复的对象。</p>
<p>下面简单的介绍一下本人的思路。</p>
<h3 id="文件准备"><a href="#文件准备" class="headerlink" title="文件准备"></a>文件准备</h3><p>因为百万级数据的清理在单机模式下其实是很耗时的操作，所以我们需要考虑到一些异常的发生，并且要暂存一下重复的key值，所以需要构建三个临时文件</p>
<blockquote>
<p>touch out.json set.json error.json</p>
</blockquote>
<p>分别代表输出文件，key值暂存文件，以及错误文件</p>
<h3 id="重试机制的简单实现"><a href="#重试机制的简单实现" class="headerlink" title="重试机制的简单实现"></a>重试机制的简单实现</h3><p>有时调用es进行查询会出现超时的情况，为了防止服务的直接停止，我们需要捕获异常进行处理。</p>
<p>对于重试，思路如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 重试超过三次后退出并写入错误文件中</span></span><br><span class="line">    <span class="keyword">if</span> (map.getOrDefault(key, <span class="number">0</span>) &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">    FileWriter fw2 = <span class="keyword">new</span> FileWriter(errorFile, <span class="keyword">true</span>);</span><br><span class="line">    fw2.write(<span class="string">"\""</span> + key + <span class="string">"\""</span> + <span class="string">","</span>);</span><br><span class="line">    fw2.close();</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    log.warn(<span class="string">"error!"</span>, e);</span><br><span class="line">    <span class="comment">// 当失败时放入队列头部</span></span><br><span class="line">    list.addFirst(key);</span><br><span class="line">    map.put(key,map.getOrDefault(key, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们使用一个map来统计当前key的失败次数，进入异常后判断一下当前失败次数，当超过3次后，写入错误文件，并跳到下一个key，未达到三次时，放入队列头部，下次继续重试</p>
<h3 id="开始清洗"><a href="#开始清洗" class="headerlink" title="开始清洗"></a>开始清洗</h3><p>首先将数据读取到队列中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String content = FileUtils.readFileToString(file, <span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="comment">// 提取json的values</span></span><br><span class="line">JSONObject jsonObject = JSONObject.fromObject(content);</span><br><span class="line">LinkedList&lt;String&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;(jsonObject.values());</span><br></pre></td></tr></table></figure>
<p>然后通过当前key去es中查找唯一的对象，再通过对象值去查找与之相似的key，存入set中。</p>
<p>删除队列中存在的相似key</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.removeAll(set);</span><br></pre></td></tr></table></figure>
<p>最好统计一下当前运行的进度，比如每一千个输出一次</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (count % <span class="number">1000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 已清洗数据量</span></span><br><span class="line">    log.info(<span class="string">"count: "</span> + count);</span><br><span class="line">    <span class="comment">// 已删除数据量</span></span><br><span class="line">    log.info(<span class="string">"cleanCount: "</span> + cleanCount);</span><br><span class="line">    FileWriter fw1 = <span class="keyword">new</span> FileWriter(setFile, <span class="keyword">true</span>);</span><br><span class="line">    fw1.write(<span class="string">"\""</span> + count + <span class="string">"\":"</span> + <span class="string">"\""</span> + cleanCount + <span class="string">"\""</span> + <span class="string">","</span>);</span><br><span class="line">    fw1.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>今天的介绍就到这里了，如有问题，请联系博主</p>
<p><strong>付出不到，就不要想着收获</strong></p>
]]></content>
      
        <categories>
            
            <category> web </category>
            
        </categories>
        
        
        <tags>
            
            <tag> web </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【java】打出指定类的jar包]]></title>
      <url>/2018/04/23/jar/</url>
      <content type="html"><![CDATA[<p>最近接到了一个需求，由于两个服务较为耦合，需要复制多个pojo，为了防止这种冗余操作，所以选择了引入jar包的方法，今天来介绍一下如何打出指定类的jar包</p>
<p>首先拿我原来写的用户中心为例子，在调用时，我可能需要一些pojo来进行反序列化对象</p>
<ol>
<li><p>首先使用maven插件进行打包<br><img src="https://upload-images.jianshu.io/upload_images/9252736-bbc253f659a77a78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="maven插件打包"></p>
</li>
<li><p>然后我们找到这个jar，将其解压<br><img src="https://upload-images.jianshu.io/upload_images/9252736-6300741cfffd7094.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="解压结构图"></p>
</li>
<li><p>可以看出，这个jar包中包括了我们整个项目，但我们只需要data包，这是我们删除其他所有的冗余包，<strong>一定要保留完整路径，否则引入后编译时会找不到包</strong>。<br><img src="https://upload-images.jianshu.io/upload_images/9252736-c814d6b48ed2876e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="删除后结构图"></p>
</li>
<li><p>然后使用jar cvf usercenter.data.jar com 命令将删除冗余后的文件夹打成jar包</p>
</li>
<li><p>在pom.xml的同级目录下创建libs，将jar放入，然后在pom.xml中引入如下语句</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;usercenter&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;data&lt;/artifactId&gt;</span><br><span class="line">			&lt;scope&gt;system&lt;/scope&gt;</span><br><span class="line">			&lt;systemPath&gt;$&#123;basedir&#125;/libs/usercenter.data.jar&lt;/systemPath&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<ol>
<li>然后我们就可以在项目中进行使用了</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/9252736-a10338dafa42eec4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="使用图"></p>
<p>今天的介绍就到这里了，虽然很简单，但有时你也许会用上。</p>
<p><strong>浩瀚的星辰，究竟何处才是我的归宿</strong></p>
]]></content>
      
        <categories>
            
            <category> jar </category>
            
        </categories>
        
        
        <tags>
            
            <tag> jar </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用kafka+logback，异步持久化日志]]></title>
      <url>/2018/04/07/LogAndKafka/</url>
      <content type="html"><![CDATA[<p>最近一直在忙着攻克个人开源的用户中心中异步日志的功能，今天终于完成了这个困扰我许久的问题。</p>
<h3 id="服务器kafka如何配置"><a href="#服务器kafka如何配置" class="headerlink" title="服务器kafka如何配置"></a>服务器kafka如何配置</h3><p>当我们没有修改配置时，会遇到生产者连接服务器失败的情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">advertised.host.name=47.94.248.38</span><br></pre></td></tr></table></figure>
<p>我们需要把host设置为当前服务器的ip</p>
<h3 id="logback配置"><a href="#logback配置" class="headerlink" title="logback配置"></a>logback配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line"></span><br><span class="line">    &lt;property name=&quot;CONSOLE_LOG_PATTERN&quot;</span><br><span class="line">              value=&quot;%date&#123;yyyy-MM-dd HH:mm:ss&#125; | %highlight(%-5level) | %boldGreen(%msg%n)&quot;/&gt;</span><br><span class="line">    &lt;appender name=&quot;KAFKA&quot; class=&quot;com.stalary.usercenter.config.KafkaAppender&quot;&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line"></span><br><span class="line">    &lt;appender name=&quot;console&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;</span><br><span class="line">        &lt;encoder&gt;</span><br><span class="line">            &lt;pattern&gt;$&#123;CONSOLE_LOG_PATTERN&#125;&lt;/pattern&gt;</span><br><span class="line">        &lt;/encoder&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line">    &lt;root level=&quot;info&quot;&gt;</span><br><span class="line">        &lt;appender-ref ref=&quot;KAFKA&quot;/&gt;</span><br><span class="line">        &lt;appender-ref ref=&quot;console&quot;/&gt;</span><br><span class="line">    &lt;/root&gt;</span><br><span class="line">    // 关闭每次显示kafka设置信息</span><br><span class="line">    &lt;logger name=&quot;org.apache.kafka&quot; level=&quot;OFF&quot;/&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
<h3 id="kafka配置"><a href="#kafka配置" class="headerlink" title="kafka配置"></a>kafka配置</h3><p>首先我们需要设置一个formatter，即对消息的格式化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Formatter &#123;</span><br><span class="line"></span><br><span class="line">    String format(ILoggingEvent event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class MessageFormatter implements Formatter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String format(ILoggingEvent event) &#123;</span><br><span class="line">        if (event.getFormattedMessage().startsWith(UCUtil.USER_LOG)) &#123;</span><br><span class="line">            return event.getLevel().toString() + UCUtil.SPLIT + event.getFormattedMessage();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们要实现一个KafkaAppender，即消息追加类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">public class KafkaAppender extends AppenderBase&lt;ILoggingEvent&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private KafkaTemplate&lt;String, String&gt; kafkaTemplate;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private Formatter formatter;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void start() &#123;</span><br><span class="line">        if (this.formatter == null) &#123;</span><br><span class="line">            this.formatter = new MessageFormatter();</span><br><span class="line">        &#125;</span><br><span class="line">        super.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void stop() &#123;</span><br><span class="line">        super.stop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void append(ILoggingEvent event) &#123;</span><br><span class="line">        Map&lt;String, Object&gt; props = new HashMap&lt;&gt;();</span><br><span class="line">        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, &quot;http://47.94.248.38:9092&quot;);</span><br><span class="line">        props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);</span><br><span class="line">        props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class);</span><br><span class="line">        props.put(ProducerConfig.REQUEST_TIMEOUT_MS_CONFIG, &quot;1000&quot;);</span><br><span class="line">        props.put(ProducerConfig.RETRIES_CONFIG, 0);</span><br><span class="line">        kafkaTemplate = new KafkaTemplate&lt;&gt;(new DefaultKafkaProducerFactory&lt;String, String&gt;(props));</span><br><span class="line">        String logStr = this.formatter.format(event);</span><br><span class="line">        if (logStr != null) &#123;</span><br><span class="line">            kafkaTemplate.send(Consumer.LOG, logStr);</span><br><span class="line">            log.info(&quot;send message: topic: &quot; + Consumer.LOG + &quot; message: &quot; + logStr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里遇到了一个坑啊，博主直接使用了自己写好的生产者不知道为什么无法发送消息，所以新申请一个KafkaTemplate</p>
<p>ILoggingEvent 则可以进行捕获日志。</p>
<p>下面来看一下消费者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@Component</span><br><span class="line">public class Consumer &#123;</span><br><span class="line"></span><br><span class="line">    public static final String LOGIN_STAT = &quot;login_stat&quot;;</span><br><span class="line"></span><br><span class="line">    public static final String LOG = &quot;center_log&quot;;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private Gson gson;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private StatService statService;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private LogService logService;</span><br><span class="line"></span><br><span class="line">    @KafkaListener(topics = &#123;LOGIN_STAT, LOG&#125;)</span><br><span class="line">    public void process(ConsumerRecord record) &#123;</span><br><span class="line">        long startTime = System.currentTimeMillis();</span><br><span class="line">        String topic = record.topic();</span><br><span class="line">        String key = &quot;&quot;;</span><br><span class="line">        if (record.key() != null) &#123;</span><br><span class="line">            key = record.key().toString();</span><br><span class="line">        &#125;</span><br><span class="line">        String message = record.value().toString();</span><br><span class="line">        if (LOGIN_STAT.equals(topic)) &#123;</span><br><span class="line">            UserStat userStat = gson.fromJson(message, UserStat.class);</span><br><span class="line">            statService.saveUserStat(userStat);</span><br><span class="line">        &#125; else if (LOG.equals(topic)) &#123;</span><br><span class="line">            String[] split = message.split(UCUtil.SPLIT);</span><br><span class="line">            String level = split[0];</span><br><span class="line">            String type = split[2];</span><br><span class="line">            Long commonId = Long.valueOf(split[3]);</span><br><span class="line">            String content = split[4];</span><br><span class="line">            // 异步存储日志</span><br><span class="line">            Log oldLog = logService.findOldLog(commonId, type, content);</span><br><span class="line">            if (oldLog != null) &#123;</span><br><span class="line">                oldLog.setCount(oldLog.getCount() + 1);</span><br><span class="line">                logService.save(oldLog);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                Log log = new Log(level, content, type, commonId, 1);</span><br><span class="line">                logService.save(log);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        long endTime = System.currentTimeMillis();</span><br><span class="line">        log.info(&quot;SubmitConsumer.time=&quot; + (endTime - startTime));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Log实体</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">@EqualsAndHashCode(callSuper = true)</span><br><span class="line">@Table(name = &quot;log&quot;)</span><br><span class="line">@Entity</span><br><span class="line">public class Log extends BaseEntity &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 日志等级</span><br><span class="line">     */</span><br><span class="line">    private String level;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 日志内容</span><br><span class="line">     */</span><br><span class="line">    private String content;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 日志种类(user，project)</span><br><span class="line">     */</span><br><span class="line">    private String type;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 通用id</span><br><span class="line">     */</span><br><span class="line">    private Long commonId;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 次数</span><br><span class="line">     */</span><br><span class="line">    private Integer count = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是完整的异步日志</p>
<p><a href="https://github.com/stalary/UserCenter" target="_blank" rel="noopener">用户中心地址</a></p>
<p>大家觉得好用可以给我的github赏点星星哦～</p>
<p><strong>你所能想到的，就能实现，技术是没有界限的</strong></p>
]]></content>
      
        <categories>
            
            <category> kafka </category>
            
            <category> log </category>
            
        </categories>
        
        
        <tags>
            
            <tag> kafka </tag>
            
            <tag> log </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SpringBoot2.0爬坑指南]]></title>
      <url>/2018/03/21/boot2/</url>
      <content type="html"><![CDATA[<p>公司的项目需要从SpringMVC迁移到SpringBoot2.0，本人用了三天的时间才基本完成迁移，今天就来大体的做一下总结</p>
<h3 id="HikariCP"><a href="#HikariCP" class="headerlink" title="HikariCP"></a>HikariCP</h3><p>SpringBoot2.0将HikariCP替换原来的Tomcat作为默认的数据库连接池(众心所向)。</p>
<p>下面就说一下在配置中我们需要做的变化</p>
<p>原来我们在配置读写分离的数据库，是这样配置的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.readwrite.url=jdbc:mysql:<span class="comment">//127.0.0.1:3306/bookSystem?characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line">spring.datasource.readwrite.username=root</span><br><span class="line">spring.datasource.readwrite.password=<span class="number">123456</span></span><br><span class="line">spring.datasource.readwrite.driver-<span class="class"><span class="keyword">class</span>-<span class="title">name</span></span>=com.mysql.jdbc.Driver</span><br></pre></td></tr></table></figure>
<p>如果升级后还保持原有配置会出现错误</p>
<blockquote>
<p>HikariPool-1 - jdbcUrl is required with driverClassName</p>
</blockquote>
<p>而在升级以后我们需要如何配置呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.readwrite.jdbc-url=jdbc:mysql:<span class="comment">//127.0.0.1:3306/bookSystem?characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line">spring.datasource.readwrite.username=root</span><br><span class="line">spring.datasource.readwrite.password=<span class="number">123456</span></span><br><span class="line">spring.datasource.readwrite.driver-<span class="class"><span class="keyword">class</span>-<span class="title">name</span></span>=com.mysql.jdbc.Driver</span><br></pre></td></tr></table></figure>
<p>可以看出url前面加上了jdbc</p>
<p>当然既然是使用了读写分离的数据库，光做这些是不够的，需要进行手动配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="comment">// 设置为首选的数据源</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="comment">// 读取配置</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix=<span class="string">"spring.datasource.readwrite"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> DataSourceBuilder.create().build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也许有的朋友还不知道配置文件是如何读取到配置类的我们就简单说一下</p>
<ul>
<li>配置文件中写一个name</li>
<li>在需要匹配的类中有一个name属性</li>
<li>这样就会一一对应进行读取</li>
</ul>
<p>可能上面说的有点抽象，下面通过一个实例来进行进一步的解释</p>
<p>application.yml写了这样几行配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">props:</span><br><span class="line">  map:</span><br><span class="line">    key: 123</span><br><span class="line">    key1: 456</span><br><span class="line">  test: 123456</span><br></pre></td></tr></table></figure>
<p>读取类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"props"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Props</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String test;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现我们先配置一个前缀，让配置类找到props，然后通过属性与配置的一一对应进行匹配，现在明白了如何配置，我们就来看一下HikariConfig</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String driverClassName;</span><br><span class="line"><span class="keyword">private</span> String jdbcUrl;</span><br></pre></td></tr></table></figure>
<p>我们可以从源码中看到这两个属性，这也就是我们要设置jdbc-url的原因</p>
<p><strong>故事到这里只是刚刚开始，请大家耐心去看</strong></p>
<h3 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a>Gradle</h3><p>springboot2默认需要4.0以上的gradle了，所以我们修改一下gradle-wrapper.properties</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">distributionUrl=https\:<span class="comment">//services.gradle.org/distributions/gradle-4.1-all.zip</span></span><br></pre></td></tr></table></figure>
<p>还有一个重要的地方，gradle的依赖管理进行了升级，在gradle中加入一个插件即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: <span class="string">'org.springframework.boot'</span></span><br><span class="line">apply plugin: <span class="string">'io.spring.dependency-management'</span></span><br></pre></td></tr></table></figure>
<p>在打包时的命令也发生了变化，可以使用<strong>gradle bootjar</strong>或者<strong>gradle bootwar</strong>来进行打包，然后<strong>gradle bootrun</strong>运行</p>
<p>当然，要补充一点，在boot2.0迁移的官方文档中说，推荐我们加入</p>
<blockquote>
<p>runtime(“org.springframework.boot:spring-boot-properties-migrator”)</p>
</blockquote>
<p>只要将其作为依赖添加到项目中，它不仅会分析应用程序的环境并在启动时打印诊断信息，而且还会在运行时为项目临时迁移属性</p>
<p>ps: boot2的报错真的有点少，我遇到了多次什么报错信息都没有Hikari就自动关闭的情况</p>
<h3 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h3><p>由于我们的项目还是使用的Hibernate，所以起初想着平滑迁移，便没有改变，但是发现在Hibernate5.2.1以上已经不推荐Criteria，这代表着正在逐渐向JPA标准化进行过度，所以下面给出两种替换方式</p>
<h4 id="JPA"><a href="#JPA" class="headerlink" title="JPA"></a>JPA</h4><p>demo</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 传入Pageable对象和quizId，返回一个Page对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">QuizRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">QuizEntity</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">Page&lt;QuizEntity&gt; <span class="title">findByQuizId</span><span class="params">(<span class="keyword">long</span> quizId, Pageable pageable)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Pageable</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PageRequest pageRequest = PageRequest.of(page - <span class="number">1</span>, size, Sort.by(Sort.Direction.DESC, <span class="string">"createTime"</span>));</span><br></pre></td></tr></table></figure>
<h4 id="CriteriaBuilder"><a href="#CriteriaBuilder" class="headerlink" title="CriteriaBuilder"></a>CriteriaBuilder</h4><p>demo</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuizDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入EntityManager</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> EntityManager entityManager;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Pair&lt;Long, List&lt;QuizEntity&gt;&gt; search(String keyword, <span class="keyword">int</span> page, <span class="keyword">int</span> size) &#123;</span><br><span class="line">        <span class="comment">// 创建构造器</span></span><br><span class="line">        CriteriaBuilder builder = entityManager.getCriteriaBuilder();</span><br><span class="line">        <span class="comment">// 设置语句查询对应的实体     </span></span><br><span class="line">        CriteriaQuery&lt;QuizEntity&gt; criteria = builder.createQuery(QuizEntity.class);</span><br><span class="line">        <span class="comment">// 设置from的来源</span></span><br><span class="line">        Root&lt;QuizEntity&gt; root = criteria.from(QuizEntity.class);</span><br><span class="line">        <span class="comment">// 设置查询的条件</span></span><br><span class="line">        criteria.where(builder.ge(root.get(<span class="string">"status"</span>), <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 设置排序的属性</span></span><br><span class="line">        criteria.orderBy(builder.asc(root.get(<span class="string">"createTime"</span>)));</span><br><span class="line">        TypedQuery&lt;QuizEntity&gt; query = entityManager.createQuery(criteria);</span><br><span class="line">        <span class="comment">// 获取总数据量</span></span><br><span class="line">        <span class="keyword">long</span> total = query.getResultList().size();</span><br><span class="line">        <span class="comment">// 设置第几页，和每页的数据</span></span><br><span class="line">        query.setFirstResult((page - <span class="number">1</span>) * size);</span><br><span class="line">        query.setMaxResults(size);</span><br><span class="line">        List&lt;QuizEntity&gt; resultList = query.getResultList();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;&gt;(total, resultList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现一种更加方便快捷，一种更加灵活，大家可以自行选型，但当我使用JPA时，遇到了问题。</p>
<p>在我使用UPDATE时发生了error，最后发现需要进行事务和标注</p>
<p>demo</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>(rollbackFor = Exception.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">QuizRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">QuizEntity</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Modifying</span></span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"update tr_quiz q set q.readState=true where q.quizId = ?1 and q.lessonId = ?2 and q.status &gt;= 0"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">readAll</span><span class="params">(<span class="keyword">long</span> quizId, <span class="keyword">long</span> lessonId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>@Transactional和@Modifying注解大家一定不要忘记。</p>
</blockquote>
<h3 id="lombok"><a href="#lombok" class="headerlink" title="lombok"></a>lombok</h3><p>lombok相信大家基本都用过，就是可以通过注解来生成构造函数，getset方法等的包，而在boot2中引入最新版时，遇到了一些问题</p>
<p>通过查看官方文档，发现了下面这句话</p>
<blockquote>
<p>BREAKING CHANGE: lombok config key lombok.addJavaxGeneratedAnnotation now defaults to false instead of true. Oracle broke this annotation with the release of JDK9, necessitating this breaking change.</p>
<p>lombok在最新版本中默认lombok.addJavaxGeneratedAnnotation为false</p>
</blockquote>
<p>这导致了通过http请求获取数据进行转化时的失败，需要我们手动配置一下，所以我选择了降级到1.16.18省去配置的麻烦</p>
<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>如果使用的client为Jedis，那恭喜你，你又需要做转变了，因为boot2.0中默认为lettuce，我们需要修改一下gradle的配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">compile(<span class="string">'org.springframework.boot:spring-boot-starter-data-redis'</span>) &#123;</span><br><span class="line">        exclude <span class="keyword">module</span>: <span class="string">'lettuce-core'</span></span><br><span class="line">    &#125;</span><br><span class="line">    compile(<span class="string">'redis.clients:jedis'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Cassandra"><a href="#Cassandra" class="headerlink" title="Cassandra"></a>Cassandra</h3><p>我们集群中的Cassandra版本比较老，所以不能使用</p>
<blockquote>
<p>compile(‘org.springframework.boot:spring-boot-starter-cassandra’)</p>
</blockquote>
<p>需要使用</p>
<blockquote>
<p>compile(‘com.datastax.cassandra:cassandra-driver-core:2.1.7.1’)  compile(‘com.datastax.cassandra:cassandra-driver-mapping:2.1.7.1’)</p>
</blockquote>
<p>但是，引入包后一直发生错误，又是Hikari自动停止，后来仔细观察了包的依赖关系(使用./gradlew dependencyInsight –dependency cassandra-driver-core可以分析)</p>
<p>发现在mapping中包含了core，于是去掉core，果然项目跑起来了-   -，很激动。</p>
<h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><p>最后再来说一下kafka在boot中的基本使用，今天直接少最简单的一种单线程消费</p>
<p>我们只需要创建两个类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@KafkaListener</span>(topics = &#123;<span class="string">"test"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(ConsumerRecord record)</span> </span>&#123;</span><br><span class="line">        String topic = record.topic();</span><br><span class="line">        String key = record.key().toString();</span><br><span class="line">        String message = record.value().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> KafkaTemplate&lt;String, String&gt; kafkaTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String topic, String message)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"send message: topic: "</span> + topic + <span class="string">" message: "</span> + message);</span><br><span class="line">        kafkaTemplate.send(topic, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String topic, String key, String message)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"send message: topic: "</span> + topic + <span class="string">" key: "</span> + key + <span class="string">" message: "</span> + message);</span><br><span class="line">        kafkaTemplate.send(topic, key, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>怎么样？是不是很简单，但一定不要忘了在application.properties里配置一下，下面给出基本的配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#kafka</span><br><span class="line">#producer</span><br><span class="line"><span class="comment">// bootstrap-servers代替原来的broker.list</span></span><br><span class="line">spring.kafka.bootstrap-servers=localhost:<span class="number">9092</span></span><br><span class="line"><span class="comment">// 生产者key的序列化方式</span></span><br><span class="line">spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer</span><br><span class="line"><span class="comment">// 生产者value的序列化方式</span></span><br><span class="line">spring.kafka.producer.value-serializer=org.apache.kafka.common.serialization.StringSerializer</span><br><span class="line"></span><br><span class="line">#consumer</span><br><span class="line">spring.kafka.consumer.group-id=test_group</span><br><span class="line">spring.kafka.consumer.enable-auto-commit=<span class="keyword">true</span></span><br><span class="line"><span class="comment">// 消费者key的反序列化方式</span></span><br><span class="line">spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer</span><br><span class="line"><span class="comment">// 消费者value的反序列化方式</span></span><br><span class="line">spring.kafka.consumer.value-deserializer=org.apache.kafka.common.serialization.StringDeserializer</span><br></pre></td></tr></table></figure>
<p>最后，当调试时不要忘记在application。properties中设置</p>
<blockquote>
<p>debug=true</p>
</blockquote>
<p>打开debug可以看到更清晰的调试信息。</p>
<p>吃水不忘挖井人，附上boot2.0的官方迁移文档<br><a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.0-Migration-Guide" target="_blank" rel="noopener">官方迁移文档</a></p>
<p><strong>最激动人心的不是站在高处时的耀眼，而是无人问津时的默默付出</strong></p>
]]></content>
      
        <categories>
            
            <category> spring </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【orm】三种框架的分析]]></title>
      <url>/2018/03/20/hibernateAndJpaAndMybaits/</url>
      <content type="html"><![CDATA[<p>最近，项目正在逐渐从SpringMVC迁移到SpringBoot，发现原来Hibernate使用的Criteria已经被标记为淘汰，所以今天对dao中三种使用方式进行总结</p>
<h3 id="JPA"><a href="#JPA" class="headerlink" title="JPA"></a>JPA</h3><p>JPA的方便之处在于，如果方法名规范，可以直接映射到sql语句，缺点是有些复杂的sql语句会不太灵活</p>
<p>下面看一个demo</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入Pageable对象和quizId，返回一个Page对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">QuizRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">QuizEntity</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">Page&lt;QuizEntity&gt; <span class="title">findByQuizId</span><span class="params">(<span class="keyword">long</span> quizId, Pageable pageable)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到仅仅通过命名，就直接完成了dao的操作，但是当需要进行动态拼接sql时，可能就有点力不从心，可以书写多个dao，在service进行分别调用也可以使用mybatis框架。</p>
<h3 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h3><p>Hibernate在更新后，老得语法已经标记为淘汰，今天就来分享一下新语法的使用，下面先分享一下5.2.1的文档地址<br><a href="http://docs.jboss.org/hibernate/orm/5.2/userguide/html_single/Hibernate_User_Guide.html#criteria" target="_blank" rel="noopener">Hibernate 5.2.1</a></p>
<p>具体的使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuizDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入EntityManager</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> EntityManager entityManager;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Pair&lt;Long, List&lt;QuizEntity&gt;&gt; search(String keyword, <span class="keyword">int</span> page, <span class="keyword">int</span> size) &#123;</span><br><span class="line">        <span class="comment">// 创建构造器</span></span><br><span class="line">        CriteriaBuilder builder = entityManager.getCriteriaBuilder();</span><br><span class="line">        <span class="comment">// 设置语句查询对应的实体     </span></span><br><span class="line">        CriteriaQuery&lt;QuizEntity&gt; criteria = builder.createQuery(QuizEntity.class);</span><br><span class="line">        <span class="comment">// 设置from的来源</span></span><br><span class="line">        Root&lt;QuizEntity&gt; root = criteria.from(QuizEntity.class);</span><br><span class="line">        <span class="comment">// 设置查询的条件</span></span><br><span class="line">        criteria.where(builder.ge(root.get(<span class="string">"status"</span>), <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 设置排序的属性</span></span><br><span class="line">        criteria.orderBy(builder.asc(root.get(<span class="string">"createTime"</span>)));</span><br><span class="line">        TypedQuery&lt;QuizEntity&gt; query = entityManager.createQuery(criteria);</span><br><span class="line">        <span class="comment">// 获取总数据量</span></span><br><span class="line">        <span class="keyword">long</span> total = query.getResultList().size();</span><br><span class="line">        <span class="comment">// 设置第几页，和每页的数据</span></span><br><span class="line">        query.setFirstResult((page - <span class="number">1</span>) * size);</span><br><span class="line">        query.setMaxResults(size);</span><br><span class="line">        List&lt;QuizEntity&gt; resultList = query.getResultList();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;&gt;(total, resultList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的例子看，hibernate操作还是比较繁琐的，但是语句拼接更加灵活。</p>
<h3 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h3><p>Mybatis如同一种半自动化的框架，与Hibernate的全自动化不同，需要我们自己手动编写SQL语句，但也带来了更大的便利性</p>
<p>下面给出一个小demo，没有使用xml，而是直接使用了注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BookDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String TABLE_NAME = <span class="string">"book"</span>;</span><br><span class="line">    String ALL_FIELDS = <span class="string">" id, bookName, userId, coverUrl, pdfUrl, downloadCount, createTime, updateTime, status"</span>;</span><br><span class="line">    String INSERT_FIELDS = <span class="string">" bookName, userId, coverUrl, pdfUrl, createTime, updateTime"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得所有图书，按照上传时间和分数降序排序，并进行分页</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 图书List</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Select</span>(&#123;SystemUtil.SELECT, ALL_FIELDS, SystemUtil.FROM, TABLE_NAME, SystemUtil.WHERE, <span class="string">"status &gt;= 0"</span>,</span><br><span class="line">            <span class="string">" ORDER BY createTime DESC"</span>, <span class="string">" LIMIT #&#123;offset&#125;, #&#123;rowCount&#125;"</span>&#125;)</span><br><span class="line">    <span class="function">List&lt;Book&gt; <span class="title">findAll</span><span class="params">(@Param(<span class="string">"offset"</span>)</span> <span class="keyword">int</span> offset, @<span class="title">Param</span><span class="params">(<span class="string">"rowCount"</span>)</span> <span class="keyword">int</span> rowCount)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在项目时，我将常用的SQL关键字，抽离出来，可以防止写错，可以看出mybatis的可控性时极高的。</p>
<p>简单分析了几种dao框架后，如何选型就要根据我们自己的业务场景了，在简单业务中，使用JPA还是十分方便的。</p>
<p><strong>当想要放弃时，就想想你现在所得到的，所拥有的，都是你付出了无数汗水才得来的，你又怎能轻言放弃</strong></p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[项目上线时如何向前兼容]]></title>
      <url>/2018/03/15/forward%20compatbility/</url>
      <content type="html"><![CDATA[<p>前几天，做了许久的项目终于上线了，然而在提测的过程中，却被提出了不兼容老版本的大坑，所以今天来分析一下如何兼容老版本</p>
<h3 id="兼容方法"><a href="#兼容方法" class="headerlink" title="兼容方法"></a>兼容方法</h3><p>我们可以在客户端请求接口时，在全局请求中加入一个api_version，服务端在拦截器中获取到api_version的参数，来判断调用哪个版本的接口，这就类似于门面模式，对外使用统一接口，但是内部逻辑各版本会不相同</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9252736-105d76df4b31ac02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="调用图片"></p>
<h3 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h3><p>不要以为版本适配这样就很完美了，当项目上线后才发现了一个巨大的坑，通过消息队列读取的消息，异步处理时，由于无法接受到请求的版本号，所以发生了一直走不到新接口的bug，经过了三个小时的排查才发现了这个bug，最后使用了特殊标示才解决问题。</p>
<p><strong>事情总有两面性，为了兼容我们就要写更多的代码，但这是必需的事情。</strong></p>
]]></content>
      
        <categories>
            
            <category> 项目，兼容 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【Java】HashMap深入分析]]></title>
      <url>/2018/03/15/hashmap/</url>
      <content type="html"><![CDATA[<p>今天来分析一下HashMap的实现原理，虽然枯燥但却是我们java学习的必经之路</p>
<h4 id="HashMap的特点"><a href="#HashMap的特点" class="headerlink" title="HashMap的特点"></a>HashMap的特点</h4><ol>
<li>线程不安全(未使用同步)</li>
<li>可以存储null的键和值(null存储在数组的第一个元素)</li>
<li>使用数组+链表+红黑树(1.8新增)实现</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/9252736-eef777005344361e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="hashmap原理图"></p>
<p>上面这张图很清晰的描述了HashMap的存储原理</p>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>put</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对传入的key进行hash运算，找到桶的位置</span></span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>hash</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="comment">// 当key为null的时候，直接存储到数组的第一个元素</span></span><br><span class="line">        <span class="comment">// 当key不为null的时候，小于十六位的直接使用hashCode，负责进行异或运算，进行进一步的hash散列</span></span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>putval</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// table未初始化或者长度为0，进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 确定元素在桶中的存储位置，如果桶为空，则生成新结点放入桶中</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 当桶中已经存在元素时</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 比较桶中第一个元素的hash值和key</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">        <span class="comment">// 当hash或者key不相等时，即不为同一个元素时，判断是否为红黑树结点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 放入树中</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 为链表结点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 在链表最末插入结点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 当到达链表的尾部</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 在尾部插入新结点</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 结点数量达到阈值，转化为红黑树并跳出循环</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) </span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断链表中结点的key值与插入的元素的key值是否相等</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 表示在桶中找到key值、hash值与插入元素相等的结点，极为相同的key</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="comment">// 记录e的value</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="comment">// onlyIfAbsent为false或者旧值为null</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">//用新值替换旧值</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">// 访问后回调</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">// 返回旧值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用于fail-fast，记录结构性修改的次数</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 实际大小大于阈值则扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 插入后回调</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>resize</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">// 当前table</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">// 保存当前table的大小</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">// 保存当前阈值 </span></span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 当之前的容量大于0时</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当之前table大于最大容量时</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">// 阈值替换为为最大整形</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当新容量等于之前容量*2并且小于最大容量，并且之前容量大于等于默认的容量</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">            oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">// 阈值翻倍</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 之前阈值大于0但是之前容量等于0时将新容量设置为之前阈值</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>)</span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="comment">// oldCap = 0并且oldThr = 0，使用缺省值（如使用HashMap()构造函数，之后再插入一个元素会调用resize函数，会进入这一步）</span></span><br><span class="line">    <span class="keyword">else</span> &#123;           </span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算新的resize上限</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当新容量和新容量*负载因子小于最大容量时，将新阈值设置为新容量*负载因子</span></span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将阈值设置为新阈值</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    <span class="comment">// 初始化table</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">// 将每个bucket移动到新的bucket中</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 复制元素，重新进行hash</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 当没有下一个节点时，新建</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// 当为红黑树时，划分树</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="comment">// 当桶为链表时</span></span><br><span class="line">                <span class="keyword">else</span> &#123; </span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="comment">// 将同一桶中的元素根据(e.hash &amp; oldCap)是否为0进行分割，分成两个不同的链表，完成rehash</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 当为0时为原索引</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 原索引+oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HashMap基本是面试必考的了，希望大家都可以掌握，同时在工程中的实践也比较广泛，但是并发的场景下，不要忘记使用ConcurrentHashMap哦。</p>
<p><strong>愿每个人的努力都不会被辜负，愿每个人都能有自己想要的生活</strong></p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
            <category> hashmap </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【java】volatile详解]]></title>
      <url>/2018/03/01/volatile%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>今天来介绍一下volatitle</p>
<h3 id="volatile是什么"><a href="#volatile是什么" class="headerlink" title="volatile是什么"></a>volatile是什么</h3><p>volatitle是一个确保共享变量能够被准确和一致地更新的关键字(保证可见性)，只能对变量使用</p>
<h3 id="volatile是如何保证可见性的"><a href="#volatile是如何保证可见性的" class="headerlink" title="volatile是如何保证可见性的"></a>volatile是如何保证可见性的</h3><p>在对有volatile修饰符修饰的共享变量进行写操作时，汇编代码回多一条lock前缀的指令。该指令有如下两个作用：</p>
<ol>
<li>将当前缓存行的数据回写到内存中</li>
<li>使其他cpu里缓存了该内存地址的数据无效(缓存一致性机制)</li>
</ol>
<p>下面通过内存模型图来继续分析</p>
<p><img src="http://upload-images.jianshu.io/upload_images/9252736-6892bb9a34e3ca96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="内存模型"></p>
<h3 id="volatile是如何防止指令重排序的"><a href="#volatile是如何防止指令重排序的" class="headerlink" title="volatile是如何防止指令重排序的"></a>volatile是如何防止指令重排序的</h3><p>首先先介绍几种内存屏障的类型</p>
<table>
<thead>
<tr>
<th>屏障类型</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>LoadLoad Barriers</td>
<td>确保Load1数据的装载先于Load2及所有后续指令的装载</td>
</tr>
<tr>
<td>StoreStore Barriers</td>
<td>确保Store1数据对其他处理器的可见(刷新到内存)先于Store2及所有后续存储指令的存储</td>
</tr>
<tr>
<td>LoadStore Barriers</td>
<td>确保Load1数据装载先于Store2及所有后续的存储指令刷新到内存</td>
</tr>
<tr>
<td>StoreLoad Barriers</td>
<td>确保Store1数据对其他处理器的可见先于Load2及所有后续装载指令的装载</td>
</tr>
</tbody>
</table>
<p>下面继续分析一下volatile是如何防止指令重排序的</p>
<ol>
<li>在每个volatile写操作的前面插入一个StoreStore屏障</li>
<li>在每个volatile写操作的后面插入一个StoreLoad屏障</li>
<li>在每个volatile读操作的后面插入一个LoadLoad屏障</li>
<li>在每个volatile读操作的后面插入一个LoadStore屏障</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/9252736-4797703b6daaaf6b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.jpg"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9252736-3074b4059057aec4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.jpg"></p>
<p>今天的介绍到这里就结束了，欢迎大家踊跃提问</p>
<p><strong>我的眼中只有那浩瀚的星辰，即便那遥不可及</strong></p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
            <category> volatile </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【java】重入锁源码分析]]></title>
      <url>/2018/02/27/ReentranLock/</url>
      <content type="html"><![CDATA[<p>今天来分析一下重入锁的源码</p>
<h3 id="ReentranLock定义"><a href="#ReentranLock定义" class="headerlink" title="ReentranLock定义"></a>ReentranLock定义</h3><p>重入锁ReentranLock是一种支持重进入的锁，表示该锁可以支持一个线程对资源重复加锁，并且分为公平锁和非公平锁</p>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>synchronized大家一定都很熟悉了，这也是一种隐式的重入锁，是一种非公平锁</p>
<h3 id="重进入的实现"><a href="#重进入的实现" class="headerlink" title="重进入的实现"></a>重进入的实现</h3><ol>
<li>当线程再次获取锁时，锁需要先判断该线程是否为当前占据锁的线程，如果是则再次成功获取</li>
<li>当释放锁时，如果线程重复n次获取了锁，必须要在第n次释放该锁后，其他线程才能够获取到该锁</li>
</ol>
<h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><p><strong>非公平锁的获取</strong></p>
<p>当再次获取同步状态时，通过判断当前线程是否为锁的持有者来决定获取操作是否成功，成功则将同步状态值增加并返回true</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断当前线程是不是锁的持有者</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取同步状态值</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 当锁没有持有者时，进行CAS操作，成功时，即将锁的拥有者设置为当前线程</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果当前线程是锁的持有者，则将同步数量增加</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="comment">// 数量错误时，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">// 数量正确时，更新同步状态值            setState(nextc);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>公平锁的获取</strong></p>
<p>与非公平锁的获取区别为，需要在CAS操作的同时判断是否还有前驱结点，当没有前驱结点时才为下一次需要执行的线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 区别只是这里需要先判断一下当前结点是否有前驱结点</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>锁的释放</strong></p>
<p>如果该锁被获取了n次，那么前n-1次tryRelease方法一定返回false，只有同步状态完全释放了才返回true，并且将锁的占有者设为空。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当前同步状态值为锁当前的被持有数减去释放数</span></span><br><span class="line">        <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">        <span class="comment">// 如果当前线程不是锁的持有者，则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 只有当锁的持有数为0时，才会将锁的持有者移除，实现锁的释放</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            free = <span class="keyword">true</span>;</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 数量不为0时，将数量写回同步状态值</span></span><br><span class="line">        setState(c);</span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="公平锁与非公平锁的区别"><a href="#公平锁与非公平锁的区别" class="headerlink" title="公平锁与非公平锁的区别"></a>公平锁与非公平锁的区别</h3><ol>
<li>公平锁比非公平锁的的效率低，因为需要切换更多次，吞吐量降低</li>
<li>公平锁能够减少饥饿发生的概率，因为非公平锁会使刚释放锁的线程再次获取同步状态的几率非常大，使得其他线程只能在AQS(同步队列)中等待</li>
</ol>
<p><strong>也许我们很渺小，但我们都要仰望星空的权利</strong></p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
            <category> 并发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【java】常用排序的整理]]></title>
      <url>/2018/02/26/sort/</url>
      <content type="html"><![CDATA[<p>今天来讲解一下几种常用的排序以及java的实现方法</p>
<ol>
<li><p>冒泡排序</p>
<ul>
<li>时间复杂度为O(n^2)</li>
<li>原理：每次比较相邻两个元素，如果顺序错误就交换</li>
<li><p>实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] bubbleSort(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span> || n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 首先比较整体数组，最大数放到数组的最后，每次循环缩小1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                swap(a, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>选择排序</p>
<ul>
<li>时间复杂度为O(n^2)</li>
<li>原理：每次选取一个最小值，放在位置0上，往后依次进行交换</li>
<li><p>实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] selectSort(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 当前下标作为最小值</span></span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="comment">// 先选出最小值，放到位置零上，然后以此类推，依次进行交换</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[min] &gt; a[j]) &#123;</span><br><span class="line">                <span class="comment">// 当下标对应的值大于当前值时，交换下标值</span></span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前下标和初始下标不相同时，进行交换</span></span><br><span class="line">        <span class="keyword">if</span> (min != i) &#123;</span><br><span class="line">            swap(a, min, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>插入排序</p>
<ul>
<li>时间复杂度为O(n^2)</li>
<li>原理：将当前数字，与之前的数字进行比较，如果大则交换，一直交换到不比当前数大的数</li>
<li><p>实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] insertSort(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span> || n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; a[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                swap(a, j, j - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>快速排序：</p>
<ul>
<li>时间复杂度为O(nlogn)</li>
<li>原理：首先选择一个基准元素，小于等于这个数的放到左边，大于的放在右边，然后对左右两部分分别递归调用快排，划分过程为O(n)</li>
<li><p>实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] quickSort(<span class="keyword">int</span>[] A, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    quickSort(A, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取最左边的值作为界限，所以要从右边开始排序</span></span><br><span class="line">    <span class="keyword">int</span> key = A[left];</span><br><span class="line">    <span class="keyword">int</span> l = left;</span><br><span class="line">    <span class="keyword">int</span> r = right;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="comment">//直到找到小于界限值的数</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; A[r] &gt;= key) &#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//直到找到大于界限值的数</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; A[l] &lt;= key) &#123;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = A[r];</span><br><span class="line">        A[r] = A[l];</span><br><span class="line">        A[l] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//左右两侧查找相遇，基数归位</span></span><br><span class="line">    A[left] = A[l];</span><br><span class="line">    A[l] = key;</span><br><span class="line">    <span class="comment">//从左右两侧继续查找</span></span><br><span class="line">    quickSort(A, left, l);</span><br><span class="line">    quickSort(A, l + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>希尔排序</p>
<ul>
<li>时间复杂度为O(nlogn)</li>
<li>原理：插入排序的改良 ，步长从大到小逐渐调整，每次与跨越步长个的数字进行比较</li>
<li><p>实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] shellSort(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span> || n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 确定步长</span></span><br><span class="line">    <span class="keyword">int</span> feet = n / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (feet &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = feet; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; j -= feet) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; feet) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (a[j] &lt; a[j - feet]) &#123;</span><br><span class="line">                    swap(a, j, j - feet);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每次步长减半</span></span><br><span class="line">        feet = feet &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>归并排序：</p>
<ul>
<li>时间复杂度为O(nlogn)</li>
<li>原理：将数组划分成多个子序列，将每个子序列进行排序，再进行合并排序</li>
<li><p>实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] mergeSort(<span class="keyword">int</span>[] A, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    mSort(A, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算中间值，每次都取一半进行划分</span></span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//划分左右</span></span><br><span class="line">    mSort(a, left, mid);</span><br><span class="line">    mSort(a, mid + <span class="number">1</span>, right);</span><br><span class="line">    <span class="comment">//合并左右</span></span><br><span class="line">    merge(a, left, mid, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[right - left + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> leftIndex = left;</span><br><span class="line">    <span class="keyword">int</span> rightIndex = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> tempIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (leftIndex &lt;= mid &amp;&amp; rightIndex &lt;= right) &#123;</span><br><span class="line">        temp[tempIndex++] = a[leftIndex] &lt; a[rightIndex] ? a[leftIndex++] : a[rightIndex++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (leftIndex &lt;= mid) &#123;</span><br><span class="line">        temp[tempIndex++] = a[leftIndex++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (rightIndex &lt;= right) &#123;</span><br><span class="line">        temp[tempIndex++] = a[rightIndex++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((t + left) &lt;= right) &#123;</span><br><span class="line">        a[t + left] = temp[t];</span><br><span class="line">        t++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>堆排序</p>
<ul>
<li>时间复杂度为O(nlogn)</li>
<li>原理：建立一个大根堆，与最小的元素交换，将根放到数组的最后，以此类推进行交换和堆的调整</li>
<li><p>实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] heapSort(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="comment">//建大根堆,每次取子结点的根结点，依次进行比较</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        heapAdjust(a, i, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        swap(a, i, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 将堆的前️i - 1项进行调整，因为第i的元素已经是最大的，无需调整</span></span><br><span class="line">        heapAdjust(a, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapAdjust</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 2 * i + 1即为子结点，+1是与建堆的-1相对应的</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">2</span> * i + <span class="number">1</span> &lt;= m) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; m &amp;&amp; a[k] &lt; a[k + <span class="number">1</span>]) &#123;<span class="comment">//找出最大的结点</span></span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a[k] &gt; a[i]) &#123;<span class="comment">//将子结点与根结点进行比较，若子结点较大，则进行交换</span></span><br><span class="line">            swap(a, k, i);</span><br><span class="line">            i = k;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p><strong>看似普通的人，总有他的过人之处</strong></p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
            <category> 排序 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【Redis】项目中Redis常用方法]]></title>
      <url>/2018/02/24/Redis/</url>
      <content type="html"><![CDATA[<p>今天来讲一讲项目中使用redis的几种用法</p>
<h3 id="实现赞踩"><a href="#实现赞踩" class="headerlink" title="实现赞踩"></a>实现赞踩</h3><p>可以使用集合或者哈希表来完成赞踩<br>使用集合的sadd和srem来完成时，首先我们需要创建两个集合，一个赞集合，一个踩集合</p>
<ul>
<li>点赞时：向赞集合添加该用户，删除踩集合中的该用户</li>
<li>踩时：向踩集合添加该用户，删除赞集合中的该用户</li>
<li>demo:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"127.0.0.1"</span>, <span class="number">6379</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String  like = <span class="string">"like:entity1"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String disLike = <span class="string">"disLike:entity1"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"like: "</span> + like(<span class="string">"user1"</span>));</span><br><span class="line">        System.out.println(<span class="string">"disLike: "</span> + disLike(<span class="string">"user1"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">like</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">        jedis.sadd(like, userId);</span><br><span class="line">        jedis.srem(disLike, userId);</span><br><span class="line">        <span class="keyword">return</span> jedis.scard(like);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">disLike</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">        jedis.sadd(disLike, userId);</span><br><span class="line">        jedis.srem(like, userId);</span><br><span class="line">        <span class="keyword">return</span> jedis.scard(disLike);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实现生产者消费者模式"><a href="#实现生产者消费者模式" class="headerlink" title="实现生产者消费者模式"></a>实现生产者消费者模式</h4><p>可以使用列表的lpush,brpop来实现，如果要实现安全模式，则使用rpoplpush</p>
<ul>
<li>生产者使用lpush将消息放入列表中</li>
<li>消费者使用brpop阻塞的从列表中取出消息</li>
<li>demo</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        executor.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    publish(<span class="string">"message: "</span> + i);</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        executor.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                subscribe();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">publish</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"127.0.0.1"</span>, <span class="number">6379</span>);</span><br><span class="line">        jedis.lpush(<span class="string">"test"</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"127.0.0.1"</span>, <span class="number">6379</span>);</span><br><span class="line">        List&lt;String&gt; test = jedis.brpop(<span class="number">1</span>, <span class="string">"test"</span>);</span><br><span class="line">        <span class="keyword">if</span> (test.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(test);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="计数器的使用"><a href="#计数器的使用" class="headerlink" title="计数器的使用"></a>计数器的使用</h3><p>我们可以使用incr作为计数器来统计访问次数等操作</p>
<ul>
<li>demo：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"127.0.0.1"</span>, <span class="number">6379</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        jedis.set(<span class="string">"people"</span>, <span class="string">"1"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            view();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(jedis.get(<span class="string">"people"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">view</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        jedis.incr(<span class="string">"people"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="统计用户一段时间内的上线次数"><a href="#统计用户一段时间内的上线次数" class="headerlink" title="统计用户一段时间内的上线次数"></a>统计用户一段时间内的上线次数</h3><p>可以使用setbit和bitcount来进行统计上线次数</p>
<ul>
<li>使用setbit在指定的天将该位置为1</li>
<li>使用bitcount统计登录天数</li>
<li>demo：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"127.0.0.1"</span>, <span class="number">6379</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                login(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(jedis.bitcount(<span class="string">"login"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(<span class="keyword">long</span> day)</span> </span>&#123;</span><br><span class="line">        jedis.setbit(<span class="string">"login"</span>, day, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="RDB和AOF持久化的区别"><a href="#RDB和AOF持久化的区别" class="headerlink" title="RDB和AOF持久化的区别"></a>RDB和AOF持久化的区别</h3><ul>
<li>RDB：定期提交save进行备份<ul>
<li>优点：<ul>
<li>文件紧凑，体积较小</li>
<li>适合灾难恢复</li>
<li>可最大化redis的性能</li>
<li>恢复数据速度比aof快</li>
</ul>
</li>
<li>缺点：<ul>
<li>有可能会丢失数据(未到保存点时，发生故障)</li>
<li>每次保存时需要fork出一个子进程，数据较大时，停止时间较长</li>
</ul>
</li>
</ul>
</li>
<li>AOF：持续用日志记录些操作，crash后利用日志进行恢复<ul>
<li>优点：<ul>
<li>使redis变得更加耐久，不会丢失数据</li>
<li>对日志是追加操作，不需要seek</li>
<li>可以在提交较大时自动在后台进行重写</li>
<li>有序的保证了所有写入操作</li>
</ul>
</li>
<li>缺点：<ul>
<li>体积大于rdb</li>
<li>在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间</li>
<li>重新载入时，可能无法将数据集恢复成保存时的原样</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>今天的分享到这里就结束了，愿我们每一天都不会忘记自己的梦想，每天都会明白我们所想要的是什么</p>
<p><strong>曾经我们梦想离乡，而当那天真正到来时，我们却无尽的思乡</strong></p>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【java】Iterator源码分析]]></title>
      <url>/2018/02/15/IteratorAndCollection/</url>
      <content type="html"><![CDATA[<p>除夕夜，当然也不能忘记了敲代码，今天来分享一下Iterator的一些小知识</p>
<h3 id="Iterator的源码分析"><a href="#Iterator的源码分析" class="headerlink" title="Iterator的源码分析"></a>Iterator的源码分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否还有下一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取游标当前元素</span></span><br><span class="line"><span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 删除游标当前元素</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"remove"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1.8中使用的遍历方法</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">while</span> (hasNext())</span><br><span class="line">            action.accept(next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>demo:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Iterator&lt;Integer&gt; it = list.iterator(); it.hasNext();) &#123;</span><br><span class="line">            Integer number = it.next();</span><br><span class="line">            <span class="keyword">if</span> (number % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                it.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="number">4</span>);</span><br><span class="line">        Iterator iterator = list.iterator();</span><br><span class="line">        iterator.forEachRemaining(o -&gt; System.out.print(o + <span class="string">" "</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>output:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">5</span> <span class="number">2</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>
<h3 id="异常原因："><a href="#异常原因：" class="headerlink" title="异常原因："></a>异常原因：</h3><p>NoSuchElementException</p>
<blockquote>
<p>当游标移动到末尾时，再调用next方法，就会报出这个异常，代表不存在元素</p>
</blockquote>
<p>UnsupportedOperationException</p>
<blockquote>
<p>有些方法没有对remove方法进行重写，所以会抛出默认的<br>throw new UnsupportedOperationException(“remove”);</p>
</blockquote>
<p>NullPointerException</p>
<blockquote>
<p>当传入的动作为空时会抛出这个异常</p>
</blockquote>
<p>IllegalStateException</p>
<blockquote>
<p>当调用remove之前没有调用next时会抛出这个异常</p>
</blockquote>
<p>ConcurrentModificationException</p>
<blockquote>
<p>并发异常，当modCount和expectedModCount不一致时，会抛出该异常，后面会详细介绍一下这个问题</p>
</blockquote>
<h3 id="Iterator和集合方法为什么不能一起使用？"><a href="#Iterator和集合方法为什么不能一起使用？" class="headerlink" title="Iterator和集合方法为什么不能一起使用？"></a>Iterator和集合方法为什么不能一起使用？</h3><p>首先来看一下下面这段代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">        Iterator&lt;Integer&gt; it = set.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            Integer number= it.next();</span><br><span class="line">            <span class="keyword">if</span> (number % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                set.remove(number);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码抛出了ConcurrentModificationException的异常，由于Set的底层是由HashMap实现的，所以我们看一下源码来分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Node&lt;K,V&gt; p = current;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            current = <span class="keyword">null</span>;</span><br><span class="line">            K key = p.key;</span><br><span class="line">            removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>这里我们看到了modCount和expectedModCount，modCount是记录HashMap的修改次数，而expectedModCount是HashIterator的修改次数，属于两个不同的计数器。</p>
</li>
<li><p>当使用Iterator进行遍历的同时，调用set的remove方法时，会造成两个计数器不同步的现象，所以抛出了ConcurrentModificationException，当然add方法也是相同的道理。</p>
</li>
<li><p>所以我们可以知道有时抛出并发异常并不是由于多线程并发造成的，而是由于计数器的不一致</p>
</li>
</ul>
<p><strong>只有永不停歇的前进，才能保证不会后退</strong></p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
            <category> Iterator </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【web】分布式session]]></title>
      <url>/2018/02/12/DistributedSession/</url>
      <content type="html"><![CDATA[<p>今天我们来讲解一下分布式Session的几种实现方法</p>
<h3 id="为什么要使用分布式Session"><a href="#为什么要使用分布式Session" class="headerlink" title="为什么要使用分布式Session"></a>为什么要使用分布式Session</h3><p>在分布式场景下，负载均衡会将用户请求随机分发，如果单机存储Session，会造成用户需要频繁登陆。</p>
<h3 id="分布式Session的实现方式"><a href="#分布式Session的实现方式" class="headerlink" title="分布式Session的实现方式"></a>分布式Session的实现方式</h3><ul>
<li>粘性Session(将用户请求固定在一台服务器)</li>
<li>服务器Session复制(广播实现Session同步)</li>
<li>缓存存储(Sticky模式和Non-Sticky模式)</li>
<li>持久化存储(将Session存储到数据库)</li>
</ul>
<h4 id="粘性Session"><a href="#粘性Session" class="headerlink" title="粘性Session"></a>粘性Session</h4><ul>
<li><strong>原理：</strong>将用户锁定到某一台服务器上，用户的每次请求都会被发送到第一次请求的服务器上。</li>
<li><strong>优点：</strong>简单易用，无需操作Session，直接配置Nginx即可。</li>
<li><strong>缺点：</strong>缺乏容错性，如果当前访问的服务器发生宕机，请求被转发到其他服务器，用户需要重新登录。 </li>
</ul>
<h4 id="服务器Session复制"><a href="#服务器Session复制" class="headerlink" title="服务器Session复制"></a>服务器Session复制</h4><ul>
<li><strong>原理：</strong>任何一个节点的Session发生变化，都会广播给其他所有节点，以保证Session的同步。</li>
<li><strong>优点：</strong>容错性较强，Session可以实时响应。</li>
<li><strong>缺点：</strong>会影响到网络负荷，当并发量较大时，会降低服务器的性能。</li>
</ul>
<h4 id="缓存存储"><a href="#缓存存储" class="headerlink" title="缓存存储"></a>缓存存储</h4><ul>
<li><strong>原理：</strong><ul>
<li>Sticky模式：请求处理完成后，将Session同步到缓存中，每次请求都会被映射到同一台服务器，直到服务器宕机，再去缓存中读取Session。</li>
<li>Non-Sticky模式：每次请求被映射到的随机一台服务器，请求到来时从缓存中加载Session，请求处理完成，再将Session回写到缓存中。</li>
</ul>
</li>
<li><strong>优点：</strong>容错性较强，Session可以实时响应。</li>
<li><strong>缺点：</strong>一旦缓存重启，Session也会丢失(Redis默认保存快照，不会丢失)，需要重新登录。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/9252736-2f4cc3428077c777.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h4 id="持久化存储"><a href="#持久化存储" class="headerlink" title="持久化存储"></a>持久化存储</h4><ul>
<li><strong>原理：</strong>将Session存到数据库中，进行持久化。</li>
<li><strong>优点：</strong>服务器宕机，Session不会丢失。</li>
<li><strong>缺点：</strong>高并发时，对数据库造成很大的压力。</li>
</ul>
<p>参考</p>
<ul>
<li>集群/分布式环境下5种session处理策略：<a href="http://blog.csdn.net/u010028869/article/details/50773174?ref=myread" target="_blank" rel="noopener">http://blog.csdn.net/u010028869/article/details/50773174?ref=myread</a></li>
<li>《大型分布式网站架构设计与实践》</li>
</ul>
<p><strong>我们今天所付出的一切，不过是为了能见到明天的太阳</strong></p>
]]></content>
      
        <categories>
            
            <category> web </category>
            
            <category> 跨session </category>
            
        </categories>
        
        
        <tags>
            
            <tag> web </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【并发】并发框架之Fork/Join框架]]></title>
      <url>/2018/02/08/ForkJoin/</url>
      <content type="html"><![CDATA[<p>今天来介绍一下java并发框架之Fork/Join</p>
<h3 id="初探Fork-Join："><a href="#初探Fork-Join：" class="headerlink" title="初探Fork/Join："></a>初探Fork/Join：</h3><ul>
<li>分割任务</li>
</ul>
<blockquote>
<p>使用一个fork类来把大任务分割成子任务，当子任务还较大时，不停的分割，直到分割到子任务足够小。(类似于归并排序的分化阶段)</p>
</blockquote>
<ul>
<li>执行任务合并结果</li>
</ul>
<blockquote>
<p>分割后的子任务分别放在双端队列里，然后开启多线程分别从双端队列获取任务执行，子任务执行完的结果都放在一个队列里，然后启动一个线程从队列里获取数据，最后合并这些数据。(类似于归并排序的合并阶段)</p>
</blockquote>
<ul>
<li>举一个栗子</li>
</ul>
<blockquote>
<p>一个周末，哥们都来家里做客，我们一共七个人，而只有我会做饭，用了两个小时才做好了所有的饭菜，大家都快饿的半死才吃上了饭。</p>
<p>但是如果我把每一个菜的做法告诉其中两个人，而那两个人又去分别告诉两个人，这样他们四个人同时去做菜(假设我家比较富裕～有很多锅)，我就可以去愉快的编程了，并且只用了二十分钟所有的菜就都做好了，最后大家很开心的坐在一起吃饭。</p>
</blockquote>
<p>上面的两个小例子：当我把要做很多个菜的任务分进行分发的时候，就相当于我们今天要讲的Fork/Join框架。</p>
<ul>
<li>下面通过一幅图来更加深刻的理解</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/9252736-c6056a7e12effdee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Fork:Join运行流程图.png"></p>
<p>看完上图是不是觉得更加像归并排序了呢？<br>当然与递归也是同一个道理，都是为了划分大问题。</p>
<ul>
<li>实现原理：</li>
</ul>
<ol>
<li>ForkJoinTask的fork的实现原理</li>
</ol>
<p>当我们调用fork方法时，程序会调用ForkJoinWorkerThread的pushTask方法异步的执行任务，然后立即返回结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ForkJoinTask&lt;V&gt; <span class="title">fork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t;</span><br><span class="line">        <span class="keyword">if</span> ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread)</span><br><span class="line">            ((ForkJoinWorkerThread)t).workQueue.push(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ForkJoinPool.common.externalPush(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>push方法把当前任务存放在ForkJoinTask数组队列里，然后调用ForkJoinPool的signalWork()方法唤醒或创建一个工作线程来执行任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">            ForkJoinTask&lt;?&gt;[] a; ForkJoinPool p;</span><br><span class="line">            <span class="keyword">int</span> b = base, s = top, n;</span><br><span class="line">            <span class="keyword">if</span> ((a = array) != <span class="keyword">null</span>) &#123;    <span class="comment">// ignore if queue removed</span></span><br><span class="line">                <span class="keyword">int</span> m = a.length - <span class="number">1</span>;     <span class="comment">// fenced write for task visibility</span></span><br><span class="line">                U.putOrderedObject(a, ((m &amp; s) &lt;&lt; ASHIFT) + ABASE, task);</span><br><span class="line">                U.putOrderedInt(<span class="keyword">this</span>, QTOP, s + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> ((n = s - b) &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((p = pool) != <span class="keyword">null</span>)</span><br><span class="line">                        p.signalWork(p.workQueues, <span class="keyword">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= m)</span><br><span class="line">                    growArray();</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.ForkJoinTask的join方法的实现原理</p>
<p>调用join方法时阻塞当前线程并等待获取结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">join</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s;</span><br><span class="line">        <span class="keyword">if</span> ((s = doJoin() &amp; DONE_MASK) != NORMAL)</span><br><span class="line">            reportException(s);</span><br><span class="line">        <span class="keyword">return</span> getRawResult();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过调用doJoin方法来获取当前任务的状态</p>
<blockquote>
<p>已完成：NORMAL，直接返回任务结果<br>被取消：CANCELLED，直接抛出CancellationException<br>信号：SIGNAL<br>出现异常：EXCEPTIONAL，抛出对应异常</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">doJoin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w;</span><br><span class="line">    <span class="keyword">return</span> (s = status) &lt; <span class="number">0</span> ? s :</span><br><span class="line">        ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread) ?</span><br><span class="line">        (w = (wt = (ForkJoinWorkerThread)t).workQueue).</span><br><span class="line">        tryUnpush(<span class="keyword">this</span>) &amp;&amp; (s = doExec()) &lt; <span class="number">0</span> ? s :</span><br><span class="line">        wt.pool.awaitJoin(w, <span class="keyword">this</span>, <span class="number">0L</span>) :</span><br><span class="line">        externalAwaitDone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在doJoin()方法中，首先查看任务是否已经完成，如果执行完成则直接返回状态，没有完成，则从任务数组中取出任务并执行，顺利完成，则返回NORMAL状态，出现异常则返回EXCEPTIONAL</p>
<h3 id="Fork-Join的使用"><a href="#Fork-Join的使用" class="headerlink" title="Fork/Join的使用"></a>Fork/Join的使用</h3><p>当我们遇到一个大的耗时操作时，我们就可以对任务进行拆分，最后进行汇总，下面给出一个使用的Demo</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ForkJoinDemo</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lirongqian</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018/02/08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinDemo</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinDemo</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> canCompute = (end - start) &lt;= THRESHOLD;</span><br><span class="line">        <span class="keyword">if</span> (canCompute) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 睡一秒来模拟耗时操作</span></span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    sum += i;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">            ForkJoin.Wait waitLeft = <span class="keyword">new</span> ForkJoin.Wait(start, mid);</span><br><span class="line">            ForkJoin.Wait waitRight = <span class="keyword">new</span> ForkJoin.Wait(mid + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">            waitLeft.fork();</span><br><span class="line">            waitRight.fork();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> leftResult = waitLeft.join();</span><br><span class="line">            <span class="keyword">int</span> rightResult = waitRight.join();</span><br><span class="line">            sum = leftResult + rightResult;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> end = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">long</span> start2 = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 睡一秒来模拟耗时操作</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">        System.out.println(<span class="string">"for time: "</span> + (System.currentTimeMillis() - start2));</span><br><span class="line">        <span class="keyword">long</span> start1 = System.currentTimeMillis();</span><br><span class="line">        ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        <span class="comment">// 生成一个任务</span></span><br><span class="line">        ForkJoinDemo task = <span class="keyword">new</span> ForkJoinDemo(start, end);</span><br><span class="line">        <span class="comment">// 执行一个任务</span></span><br><span class="line">        Future&lt;Integer&gt; result = forkJoinPool.submit(task);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(result.get());</span><br><span class="line">            System.out.println(<span class="string">"Fork/Join time: "</span> + (System.currentTimeMillis() - start1));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<blockquote>
<p>55<br>for time: 10041<br>55<br>Fork/Join time: 3014</p>
</blockquote>
<p>我们可以发现，使用Fork/Join大大缩短了任务执行的时间，是不是很牛逼？大家快去自己动手试一试吧。</p>
<p><strong>编程的乐趣就在于接触到新事物时的眼前一亮</strong></p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
            <category> 并发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【java】this的几种用法]]></title>
      <url>/2018/02/06/thisDemo/</url>
      <content type="html"><![CDATA[<p>今天来分析一下Java中this关键字</p>
<h3 id="this的几种用法"><a href="#this的几种用法" class="headerlink" title="this的几种用法"></a>this的几种用法</h3><h4 id="调用其他构造函数"><a href="#调用其他构造函数" class="headerlink" title="调用其他构造函数"></a>调用其他构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThisDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThisDemo</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThisDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = <span class="number">18</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们使用一个含参的构造函数调用了一个无参构造函数。有一点需要我们注意：<br>使用this()调用构造器，必须要放在第一行，如果可以放在其他行，当ThisDemo存在父类Father时，实例化过程如下：</p>
<ul>
<li>第一行没有this()或者super()，默认执行super()</li>
<li>完成对父类对象的初始化</li>
<li>返回到子类构造函数继续执行</li>
<li>此时调用this()，将会再次调用super()，再次对父类对象初始化，这样就会产生两个对象，造成了资源的浪费</li>
</ul>
<p>所以java为了保持对象的合理性，是禁止这种操作的。</p>
<h4 id="获取当前对象的引用"><a href="#获取当前对象的引用" class="headerlink" title="获取当前对象的引用"></a>获取当前对象的引用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThisDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们调用了this的name属性，在方法中将形参name传递给成员变量name，使用this可以便于区分成员变量和局部变量，提高代码的可读性。</p>
<h4 id="代表自身对象"><a href="#代表自身对象" class="headerlink" title="代表自身对象"></a>代表自身对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThisDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ThisDemo <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThisDemo demo = <span class="keyword">new</span> ThisDemo();</span><br><span class="line">        demo.setName(<span class="string">"stalary"</span>).setAge(<span class="number">21</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里我们使用this来返回的当前的对象，可以把这个this当成一个类型为该类类型，名称为this的隐含成员变量。</p>
<h3 id="引用溢出"><a href="#引用溢出" class="headerlink" title="引用溢出"></a>引用溢出</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FinalReferenceEscape</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> FinalReferenceEscape object;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalReferenceEscape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i = <span class="number">1</span>; <span class="comment">// 写final域</span></span><br><span class="line">        <span class="keyword">this</span>.age = <span class="number">18</span>;</span><br><span class="line">        object = <span class="keyword">this</span>;<span class="comment">// this引用溢出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> FinalReferenceEscape();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (object != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(object.i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; FinalReferenceEscape.write()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; FinalReferenceEscape.read()).start();</span><br><span class="line">        System.out.println(FinalReferenceEscape.object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">FinalReferenceEscape(i=<span class="number">1</span>, age=<span class="number">18</span>)</span><br></pre></td></tr></table></figure>
<p>虽然写final域的重排序规则是可以确保的。<br>但是要除了要保证在引用变量为任意线程可见之前，该引用变量指向的对象的final域已经在构造函数中被正确初始化过，而且在构造函数内部，不能让这个引用为其他线程所见(对象引用不能在构造函数中溢出)</p>
<p>在上面的代码中：<br>一个线程执行write，一个线程执行read，这时就可能会发生下图的执行顺序<br><img src="http://upload-images.jianshu.io/upload_images/9252736-bd417527bb95d6da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="重排序.png"><br>上图表示，在构造函数还没完成时，就已经读取到了不为null的对象，构造函数中的this造成了引用的溢出。<br>所以，在构造函数返回前，被构造对象的引用不能为其他线程可见，因为此时的 final 域可能还没有被初始化。</p>
<p>主要参考资料：</p>
<blockquote>
<p>《Java并发编程的艺术》</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> java </category>
            
            <category> this </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【并发】偏向锁、轻量级锁、重量级锁的升级以及区别]]></title>
      <url>/2018/02/04/ThreeLockUpgrade/</url>
      <content type="html"><![CDATA[<p>今天来讲一下偏向锁、轻量级锁、重量级锁的升级以及区别。</p>
<h3 id="锁的状态："><a href="#锁的状态：" class="headerlink" title="锁的状态："></a>锁的状态：</h3><ul>
<li>无锁状态</li>
<li>偏向锁状态</li>
<li>轻量级锁状态</li>
<li>重量级锁状态</li>
</ul>
<p>四种状态会随着竞争的情况逐渐升级，而且是不可逆的过程，即不可降级。</p>
<blockquote>
<p>要注意的是，这四种状态都不是Java语言中的锁，而是Jvm为了提高锁的获取与释放效率而做的优化(使用synchronized时)。</p>
</blockquote>
<p>首先通过一个小例子来解释一下三种锁的区别：</p>
<blockquote>
<p>假如家里只有一个碗，当我自己在家时，没有人会和我争碗，这时即为偏向锁状态</p>
<p>当我和女朋友都在家吃饭时，如果女朋友不是很饿，则她会等我吃完再用我的碗去吃饭，这就是轻量级锁状态</p>
<p>当我和女朋友都很饿的时候，这时候就会去争抢这唯一的一个碗(贫穷的我)吃饭，这就是重量级锁状态</p>
</blockquote>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>偏向锁的由来：</p>
<blockquote>
<p>大多数情况下，锁不存在多线程竞争，而是总是由同一线程多次获得时，为了使线程获得锁的代价更低而引入了偏向锁。</p>
</blockquote>
<p>偏向锁的使用：</p>
<blockquote>
<p>当线程进入和退出同步块时，需要经历几个测试步骤：</p>
<ol>
<li>测试对象头Mark Word(默认存储对象的HashCode,分代年龄，锁标记位)里是否存储着指向当前线程的偏向锁。</li>
<li>若测试失败，则测试Mark Word中偏向锁标识是否设置成1(表示当前为偏向锁)</li>
<li>没有设置则使用CAS竞争，否则尝试使用CAS将对象头的偏向锁指向当前线程</li>
</ol>
</blockquote>
<p>偏向锁的撤销：</p>
<blockquote>
<p>当其他线程尝试竞争偏向锁时，就会释放锁，锁的撤销，需要等待全局安全点，分为以下几个步骤：</p>
<ol>
<li>暂停拥有偏向锁的线程，检查线程是否存活</li>
<li>处于非活动状态，则设置为无锁状态</li>
<li>存活，则重新偏向于其他线程或者恢复到无锁状态或者标记对象不适合作为偏向锁</li>
<li>唤醒线程</li>
</ol>
</blockquote>
<p>偏向锁的升级：</p>
<blockquote>
<p>当有第二个线程进入同步代码块时，则升级为轻量级锁</p>
</blockquote>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>轻量级锁的加锁：</p>
<blockquote>
<p>如果成功使用CAS将对象头重的Mark Word替换为指向锁记录的指针，则获得锁，失败则当前线程尝试使用自旋(循环等待)来获取锁。</p>
</blockquote>
<p>轻量级锁的解锁：</p>
<blockquote>
<p>当有另一个线程与该线程同时竞争时，锁会升级为重量级锁。为了防止继续自旋，一旦升级，将无法降级。</p>
</blockquote>
<h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>重量级锁特点：</p>
<blockquote>
<p>其他线程试图获取锁时，都会被阻塞，只有持有锁的线程释放锁之后才会唤醒这些线程，进行竞争。</p>
</blockquote>
<h3 id="三种锁的对比"><a href="#三种锁的对比" class="headerlink" title="三种锁的对比"></a>三种锁的对比</h3><p><img src="http://upload-images.jianshu.io/upload_images/9252736-d05c6e30126341fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Screen Shot 2018-02-04 at 20.15.42.png"><br>通俗来讲就是：</p>
<ul>
<li>偏向锁：仅有一个线程进入临界区</li>
<li>轻量级锁：多个线程交替进入临界区</li>
<li>重量级锁：多个线程同时进入临界区</li>
</ul>
<p>这是并发专题的第一篇博客，以后还会随时更新</p>
<p>主要参考资料：</p>
<blockquote>
<p>《Java并发编程的艺术》<br><a href="https://www.zhihu.com/question/53826114" target="_blank" rel="noopener">java偏向锁，轻量级锁与重量级锁为什么会相互膨胀?</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> java </category>
            
            <category> 并发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【java】Spring-Boot和Jpa整合开发]]></title>
      <url>/2018/02/01/SpringtBootAndJpa/</url>
      <content type="html"><![CDATA[<p>新手入门<strong>Hibernate</strong>和<strong>Mybatis</strong>以及配置繁重的<strong>Spring-MVC</strong>还有些难度，今天就从实用出发，从零开始搭建一个<strong>Spring-Boot+Jpa</strong>的服务</p>
<h3 id="什么是Jpa？"><a href="#什么是Jpa？" class="headerlink" title="什么是Jpa？"></a>什么是Jpa？</h3><p>Jpa是<strong>Java Persistence API</strong>的简称。<br>致力于通过操作<strong>对象</strong>，执行<strong>CURD</strong>操作，使开发者从繁重的jdbc和sql中脱离出来的一种规范。<br>而<strong>Hibernate ORM</strong>框架则是Jpa规范的一种<strong>实现</strong>。<br><strong>Spring Data Jpa</strong>是在Jpa规范的基础下提供了Repository层的实现</p>
<p>下图即为几种事物之间的关系：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/9252736-0aafdf713ed5086b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Screen Shot 2018-02-01 at 01.11.05.png"></p>
<h3 id="什么是Spring-Boot？"><a href="#什么是Spring-Boot？" class="headerlink" title="什么是Spring-Boot？"></a>什么是Spring-Boot？</h3><p>是一种可以方便集成各种依赖，省去大多数配置文件的自动化框架，可以基于Spring进行快速开发</p>
<h3 id="项目的搭建"><a href="#项目的搭建" class="headerlink" title="项目的搭建"></a>项目的搭建</h3><p>首先准备好IDEA<br><img src="http://upload-images.jianshu.io/upload_images/9252736-eae4a4de33816349.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Screen Shot 2018-02-01 at 01.14.18.png"></p>
<p>点击Create New Project</p>
<p><img src="http://upload-images.jianshu.io/upload_images/9252736-085107f62095be06.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Screen Shot 2018-02-01 at 01.14.58.png"></p>
<p>点击右侧的Spring Initalizr，然后点击Next</p>
<p><img src="http://upload-images.jianshu.io/upload_images/9252736-2ad0d2dd0ef494ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Screen Shot 2018-02-01 at 01.16.10.png"></p>
<p><strong>Group</strong>即为所在组<br><strong>Artifact</strong>即为项目名<br><strong>Type</strong>选择<strong>Maven Project</strong>，<strong>Maven</strong>稍后进行讲解<br><strong>Packaging</strong>选择<strong>jar</strong><br>点击<strong>Next</strong><br>有的小伙伴一定会有疑问，为什么不选择<strong>war</strong><br>这里进行说明一下，因为<strong>Spring-boot</strong>是一个自带<strong>tomcat</strong>的容器，当我们使用<strong>tomcat</strong>进行部署时，需要将<strong>war</strong>包放入到<strong>/tomcat/webapps</strong>进行运行，而<strong>Spring-boot</strong>则只需要打成<strong>jar，java -jar</strong>即可运行，是不是很方便？</p>
<p><img src="http://upload-images.jianshu.io/upload_images/9252736-2b582b43c774adb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Screen Shot 2018-02-01 at 01.24.11.png"></p>
<p>勾选上右侧我所选择的依赖，然后点击Next，再点击Finish，我们的项目就创建完成了</p>
<p><strong>Lombok</strong>大家可能还很陌生，这是一个可以极大简化开发的插件，需要在使用时勾选下图中右侧<strong>Enable annotation processing</strong>，意思是开启注解处理，因为<strong>Lombok</strong>是基于注解(在类或者方法上进行标记的一种语法)的插件</p>
<p><img src="http://upload-images.jianshu.io/upload_images/9252736-417a51c77862201a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Screen Shot 2018-02-01 at 01.26.40.png"></p>
<p>下面我们打开项目中的<strong>pom.xml</strong>，如果右下角有提示，可以点击<strong>auto-import</strong>，意思为自动导入依赖包</p>
<p><img src="http://upload-images.jianshu.io/upload_images/9252736-78d957b85b2062f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Screen Shot 2018-02-01 at 01.29.32.png"></p>
<p>下面说一下<strong>Maven</strong><br>这是一个十分便捷的依赖管理工具，我们可以通过<dependency></dependency>来直接倒入包，而不用再去网上搜索一个个的jar包<br>所以大家以后需要什么依赖可以直接去maven仓库(<a href="https://mvnrepository.com/" target="_blank" rel="noopener">https://mvnrepository.com/</a>)<br>直接复制代码过来，就可以下载依赖</p>
<p>搜索想要添加的依赖，然后点击想要的版本号(可以选择用的人数最多的，即Usages数量最大的)进入<br><img src="http://upload-images.jianshu.io/upload_images/9252736-9b8dee17bd26e145.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Screen Shot 2018-02-01 at 01.34.01.png"></p>
<p>然后复制下图中<strong>Maven</strong>里的代码到<strong>pom.xml</strong>中即可<br><img src="http://upload-images.jianshu.io/upload_images/9252736-a6e70d2a4bcd82c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Screen Shot 2018-02-01 at 01.34.09.png"></p>
<p>下面就要开始创建我们的<strong>MVC</strong>架构了<br>大家可以按照我所建的包(右键src/main/java/你的包名，即与Application同目录， new Package)来进行创建</p>
<p><img src="http://upload-images.jianshu.io/upload_images/9252736-62c8b56057786de6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Screen Shot 2018-02-01 at 01.40.43.png"></p>
<p>当然，这些只是最基本的结构，下面配置一下<strong>resources</strong>里的<strong>application.properties</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9252736-7d6363a7b5c0129f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Screen Shot 2018-02-01 at 01.45.46.png"></p>
<p>大家需要把<strong>url</strong>里的<strong>loginDemo</strong>替换成自己创建的db库名，<strong>username</strong>和<strong>password</strong>替换成自己的mysql数据库的，<strong>port</strong>为自定义的运行后的端口号</p>
<p>下面来进行编写一个简单的查询接口</p>
<p>1.我们在utils里创建一个ResponseMessage，这是用来返回数据时，返回统一格式<br><img src="http://upload-images.jianshu.io/upload_images/9252736-170c52152700db0c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Screen Shot 2018-02-01 at 02.11.28.png"><br>这里的<strong>@Data</strong>和<strong>@AllArgsConstructor</strong>和<strong>@NoArgsConstructor</strong>都是<strong>Lombok</strong>插件的注解，代表自动为实体生成<strong>get，set</strong>方法，重写<strong>toString()</strong>方法，自动生成全参，无参构造函数</p>
<p>2.创建一个和数据库中的表映射的实体类<br><img src="http://upload-images.jianshu.io/upload_images/9252736-46de3961ee8ac462.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Screen Shot 2018-02-01 at 02.11.47.png"><br><strong>@Id</strong>和<strong>@GeneratedValue</strong>代表生成表的时候设为自增主键，最后又添加了一个不含有id的构造函数，，因为不传id，就代表生成自增id，创建新数据</p>
<p>3.创建一个repository<br><img src="http://upload-images.jianshu.io/upload_images/9252736-83dd5045e969f129.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Screen Shot 2018-02-01 at 02.11.53.png"><br>要继承<strong>JpaRepository</strong>，并且泛型传入<strong>User</strong>对象<br>因为实体中设置了<strong>status=0</strong>代表正常，所以我们按照<strong>status</strong>搜出所有正常的<strong>User</strong></p>
<p>4.创建一个service<br><img src="http://upload-images.jianshu.io/upload_images/9252736-7a0e8b537876fc4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Screen Shot 2018-02-01 at 02.11.55.png"><br>通过<strong>@Autowired</strong>注入<strong>UserRepository</strong>进行调用<strong>findByStatus()</strong>方法</p>
<p>5.创建一个controller<br><img src="http://upload-images.jianshu.io/upload_images/9252736-352f285800618321.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Screen Shot 2018-02-01 at 02.12.03.png"><br><strong>@RequestController</strong>内部包含两个注解<strong>@RequestBody和@Controller</strong>代表这是一个返回json数据格式的controller<br><strong>@RequestMapping</strong>代表映射，即一会访问接口时的地址<br>内部调用service方法的getList()进行返回数据</p>
<p>6.创建test单元测试，用于增加初始数据<br><img src="http://upload-images.jianshu.io/upload_images/9252736-e79e812d219d9ecd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Screen Shot 2018-02-01 at 02.08.46.png"><br>这里<strong>Hibernate</strong>自动建的表会出现中文乱码无法插入的错误，在<strong>varchar</strong>的字段后面加上<strong>CHARACTER SET ‘utf8’</strong>即可解决<br><img src="http://upload-images.jianshu.io/upload_images/9252736-e04184eea5455d4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Screen Shot 2018-02-01 at 02.25.58.png"><br>然后点击18行的绿色按钮。Run Tests即可完成数据初始化</p>
<p>7.去BootJpaApplication点击第七行绿色按钮，Run<br><img src="http://upload-images.jianshu.io/upload_images/9252736-59bc15931f182d67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Screen Shot 2018-02-01 at 02.27.43.png"><br>打开浏览器输入url(<a href="http://localhost:8088/user/list" target="_blank" rel="noopener">http://localhost:8088/user/list</a>)<br><img src="http://upload-images.jianshu.io/upload_images/9252736-014d3cc4f29040b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Screen Shot 2018-02-01 at 02.09.43.png"><br>这样我们就拿到了数据，一个完成的项目也就搭建完成了</p>
<h3 id="项目的部署"><a href="#项目的部署" class="headerlink" title="项目的部署"></a>项目的部署</h3><p>1.在命令行中使用<strong>mvn package</strong>打成jar包<br><img src="http://upload-images.jianshu.io/upload_images/9252736-2fff89ae56ae85aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Screen Shot 2018-02-01 at 02.32.18.png"><br><strong>注意：在运行之前，先将init()中代码注释掉，否则会重复创建数据</strong></p>
<p>2.在命令行中使用<strong>java -jar target/boot-jpa-0.0.1-SNAPSHOT.jar</strong>即可开启服务，再次访问<a href="http://localhost:8088/user/list" target="_blank" rel="noopener">http://localhost:8088/user/list</a><br>依旧能够成功获取数据(开启服务前不要忘记刚才通过<strong>BootJpaApplication</strong>运行的服务)</p>
<p>一个完整的Spring-Boot+Jpa的创建到运行到部署的流程就此全部完成<br>本人github上放有基于Spring-Boot+Jpa的一个登陆demo，欢迎大家查看<br><a href="https://github.com/stalary/SpringBootDemo" target="_blank" rel="noopener">https://github.com/stalary/SpringBootDemo</a></p>
<hr>
<p>今天我们耀眼的光芒，不过是明日无人问津的落日余晖。</p>
]]></content>
      
        <categories>
            
            <category> Spring-Boot </category>
            
            <category> Jpad </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【redis】订阅发布模式的实现]]></title>
      <url>/2018/01/28/RedisSubscribeAndPublish/</url>
      <content type="html"><![CDATA[<p>最近写一个模块时，用到了缓存，由于是两个服务之间的通信，所以会遇到数据不一致的情况，最后选择了使用Redis的发布订阅模式进行解决。</p>
<h3 id="什么是发布订阅？"><a href="#什么是发布订阅？" class="headerlink" title="什么是发布订阅？"></a>什么是发布订阅？</h3><p>这就如同是我们常用的朋友圈，我们发送朋友圈时就是一个发布者，而能看到这条朋友圈的人就是一个订阅者，订阅者可以根据自己的喜好对发布的消息进行点赞，评论等操作。</p>
<p>下面贴一张形象的图片：<br><img src="http://upload-images.jianshu.io/upload_images/9252736-082d521d5111375b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>一个完整的发布订阅需要经过三个步骤：</p>
<ol>
<li><p><strong>订阅者对发布者(频道)进行订阅：</strong>比如我们想要追剧，这时就可以订阅一个节目，每天更新都会为我们发送通知</p>
</li>
<li><p><strong>发布者发送消息：</strong>发布者如同一个发令枪，发送一条消息给所有的订阅者</p>
</li>
<li><p><strong>订阅者接收消息并做出动作：</strong>当发布者发布消息时，订阅者可以对消息进行处理或者做出响应的动作</p>
</li>
</ol>
<h3 id="什么时候需要使用？"><a href="#什么时候需要使用？" class="headerlink" title="什么时候需要使用？"></a>什么时候需要使用？</h3><p>在分布式场景下，如果需要更新每一个结点的状态则可以使用发布订阅模式。</p>
<p><strong>业务场景：</strong><br>前几天我在写一个批改服务，批改服务需要首先去题库服务调用题目已经用户答案，再批改完成后需要将批改后的结果传回题库服务进行存储。</p>
<p><strong>解决方案：</strong></p>
<ol>
<li>使用kafka作为数据传递者(快递员)，实现异步(解决高并发问题)</li>
<li>使用redis与cache作为缓存</li>
<li>发布者为题库服务，订阅者为批改服务(题目服务更新完批改信息后发布消息)</li>
</ol>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 订阅者：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化时执行</span></span><br><span class="line">subscribeRedisChannel(CHANNEL_NAME);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅频道</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeRedisChannel</span><span class="params">(<span class="keyword">final</span> String channel)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"add redis PUB/SUB , refresh Channel is "</span> + channel);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    jedis.subscribe(refreshCachePubSub, channel);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.warn(<span class="string">"Redis Sub Exception"</span>, e);</span><br><span class="line">                    <span class="comment">// 订阅出现异常时，暂停1s线程</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e2) &#123;</span><br><span class="line">                        log.warn(<span class="string">"Sleep Exception"</span>, e2);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 刷新缓存</span></span><br><span class="line"><span class="keyword">private</span> JedisPubSub refreshCachePubSub = <span class="keyword">new</span> JedisPubSub() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(String channel, String message)</span> </span>&#123;</span><br><span class="line">            log.info(<span class="string">"refresh channel : "</span> + channel + <span class="string">" || refresh key : "</span> + message);</span><br><span class="line">            <span class="keyword">if</span> (CHANNEL_NAME.equals(channel)) &#123;</span><br><span class="line">                <span class="comment">// 如果存在messge即只清空对应的缓存，如果不存在则清空该cache的所有缓存</span></span><br><span class="line">                <span class="keyword">if</span> (StringUtils.isBlank(message)) &#123;</span><br><span class="line">                    cacheApi.getCache().invalidateAll();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cacheApi.getCache().invalidate(Long.parseLong(message));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 发布者：</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在更新完成后，主动调用，更新对应key的缓存</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invalidCache</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        redisService.publishRedisChannel(RedisService.CHANNEL_NAME, key);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>停更了许久的博客终于复更了。<br>人就不能闲下来。。。一旦闲下来就越来越懒<br>就如同减肥。。。总是说说，一直在增肥</p>
<p><strong>生命的意义就在于，不断的充实自己，不断的挑战自己，不断的去拥抱变化。</strong></p>
]]></content>
      
        <categories>
            
            <category> redis </category>
            
            <category> 订阅与发布 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【java】五种java线程池的使用与比较]]></title>
      <url>/2018/01/12/JavaForFivePool/</url>
      <content type="html"><![CDATA[<p>今天对五种常见的java内置线程池进行讲解。</p>
<h3 id="线程使用的demo"><a href="#线程使用的demo" class="headerlink" title="线程使用的demo"></a>线程使用的demo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ExecutorService pool = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        pool.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                sum = (<span class="keyword">int</span>) Math.sqrt(i * i - <span class="number">1</span> + i);</span><br><span class="line">                System.out.println(sum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">"cache: "</span> + (System.currentTimeMillis() - start));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h3><ul>
<li>这是一个可缓存线程池，可以灵活的回收空闲线程，无可回收线程时，新建线程</li>
</ul>
<p>源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过源码可以看出底层调用的是ThreadPoolExecutor方法，传入一个同步的阻塞队列实现缓存。</p>
<p>下面说一下ThreadPoolExecutor</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过源码可以看出，我们可以传入线程池的核心线程数(最小线程数)，最大线程数量，保持时间，时间单位，阻塞队列这些参数，最大线程数设置为jvm可用的cpu数量为最佳实践</p>
<h3 id="newWorkStealingPool"><a href="#newWorkStealingPool" class="headerlink" title="newWorkStealingPool"></a>newWorkStealingPool</h3><ul>
<li>创建持有足够线程的线程池来并行，通过使用多个队列减少竞争，不传参数，则默认设定为cpu的数量</li>
</ul>
<p>源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newWorkStealingPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinPool</span><br><span class="line">            (Runtime.getRuntime().availableProcessors(),</span><br><span class="line">             ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">             <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过源码可以看出底层调用的是ForkJoinPool线程池</p>
<p>下面说一下ForkJoinPool</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ForkJoinPool</span><span class="params">(<span class="keyword">int</span> parallelism,</span></span></span><br><span class="line"><span class="function"><span class="params">                        ForkJoinWorkerThreadFactory factory,</span></span></span><br><span class="line"><span class="function"><span class="params">                        UncaughtExceptionHandler handler,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">boolean</span> asyncMode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(checkParallelism(parallelism),</span><br><span class="line">             checkFactory(factory),</span><br><span class="line">             handler,</span><br><span class="line">             asyncMode ? FIFO_QUEUE : LIFO_QUEUE,</span><br><span class="line">             <span class="string">"ForkJoinPool-"</span> + nextPoolId() + <span class="string">"-worker-"</span>);</span><br><span class="line">        checkPermission();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>使用一个无限队列来保存需要执行的任务，可以传入线程的数量，不传入，则默认使用当前计算机中可用的cpu数量，使用分治法来解决问题，使用fork()和join()来进行调用</p>
<h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h3><p>创建一个单线程化的线程池，保证所有任务按照指定的顺序执行(FIFO,LIFO,优先级)，当要求进程限制时，可以进行使用</p>
<p>源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h3><p>创建一个固定线程数量，可重用的线程池</p>
<p>源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h3><p>创建一个可定期或者延时执行任务的线程池</p>
<p>源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br></pre></td></tr></table></figure>
<p>通过源码可以看出底层调用的是一个ScheduledThreadPoolExecutor，然后传入线程数量</p>
<p>下面来介绍一下ScheduledThreadPoolExecutor</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">              <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过源码可以看出底层调用了ThreadPoolExecutor，维护了一个延迟队列，可以传入线程数量，传入延时的时间等参数，下面给出一个demo</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ScheduledExecutorService pool = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i = i + <span class="number">5</span>) &#123;</span><br><span class="line">            pool.schedule(() -&gt; System.out.println(<span class="string">"我被执行了，当前时间"</span> + <span class="keyword">new</span> Date()), i, TimeUnit.SECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>执行结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我被执行了，当前时间Fri Jan 12 11:20:41 CST 2018</span><br><span class="line">我被执行了，当前时间Fri Jan 12 11:20:46 CST 2018</span><br><span class="line">我被执行了，当前时间Fri Jan 12 11:20:51 CST 2018</span><br></pre></td></tr></table></figure>
<p>有的小伙伴可能会用疑问，为什么使用schedule()而不使用submit()或者execute()呢，下面通过源码来分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    schedule(command, <span class="number">0</span>, NANOSECONDS);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">return</span> schedule(task, <span class="number">0</span>, NANOSECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过源码可以发现这两个方法都是调用的schedule(),而且将延时时间设置为了0，所以想要实现延时操作，需要直接调用schedule()</p>
<p>下面我们再来分析一下submit()和execute()的以及shutdown()和shutdownNow()的区别</p>
<ul>
<li>submit()，提交一个线程任务，可以接受回调函数的返回值吗，适用于需要处理返回着或者异常的业务场景</li>
<li>execute()，执行一个任务，没有返回值</li>
<li>shutdown()，表示不再接受新任务，但不会强行终止已经提交或者正在执行中的任务</li>
<li>shutdownNow()，对于尚未执行的任务全部取消，正在执行的任务全部发出interrupt()，停止执行</li>
</ul>
<h3 id="五种线程池的适应场景"><a href="#五种线程池的适应场景" class="headerlink" title="五种线程池的适应场景"></a>五种线程池的适应场景</h3><ol>
<li>newCachedThreadPool：用来创建一个可以无限扩大的线程池，当业务遇到无法确定线程多少的时候可以使用</li>
<li>newFixedThreadPool：创建一个固定大小的线程池，因为采用无界的阻塞队列，所以实际线程数量永远不会变化，适用于可以预测线程数量的业务中</li>
<li>newSingleThreadExecutor：创建一个单线程的线程池，适用于只需要一个线程的业务，避免重复启动，关闭线程</li>
<li>newScheduledThreadPool：可以延时启动，定时启动的线程池，适用于需要定时执行的业务</li>
<li>newWorkStealingPool：创建一个拥有多个任务队列的线程池，可以减少连接数，创建当前可用cpu数量的线程来并行执行，适用于大耗时的操作，可以并行来执行</li>
</ol>
<p>以上就是今天所想要分享的内容，由于并发接触并不深入，如有错误，请联系博主</p>
<p>浩瀚星辰中渺小的我们，却有着改变世界的梦想</p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
            <category> 线程池 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 线程池 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【java】Comparable和Comparator]]></title>
      <url>/2018/01/11/ComparableAndComparator/</url>
      <content type="html"><![CDATA[<p>今天来分析一下Comparable和Comparator的区别，以及源码的解读。</p>
<h3 id="Comparable"><a href="#Comparable" class="headerlink" title="Comparable"></a>Comparable</h3><ul>
<li>源码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T o)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以发现Comparable只是一个简单的泛型接口，内部含有一个compareTo接口。<br>根据接口的说明可知：</p>
<ol>
<li>实现了这个接口的集合(或者数组)可以通过使用Collections.sort()(或者Arrays.sort())进行排序</li>
<li>实现了这个接口的对象，并重写了CompareTo()方法，可以无需Comparator比较器按照key值进行排序</li>
</ol>
<ul>
<li>使用方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getAge().compareTo(o.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="string">"stalary"</span>, <span class="number">21</span>);</span><br><span class="line">        Person p3 = <span class="keyword">new</span> Person(<span class="string">"hawk"</span>, <span class="number">19</span>);</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(<span class="string">"claire"</span>, <span class="number">20</span>);</span><br><span class="line">        List&lt;Person&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(p1);</span><br><span class="line">        list.add(p2);</span><br><span class="line">        list.add(p3);</span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>实现了将对象集合按年龄的升序排序，当想实现降序排序的时候，只需要将this和p的顺序交换</li>
<li>compareTo()会返回一个整数，小于0代表小于，等于0代表等于，大于0代表大于，当返回正数时，即交换两个数，完成比较</li>
</ol>
<h3 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h3><p>当我们想要比较的对象没有实现Comparable接口时，即没发使用上述方法进行比较，这时可以使用Comparator来进行比较。</p>
<p>下面先来看一下Comparator的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">default</span> Comparator&lt;T&gt; <span class="title">reversed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.reverseOrder(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> Comparator&lt;T&gt; <span class="title">thenComparing</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (Comparator&lt;T&gt; &amp; Serializable) (c1, c2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> res = compare(c1, c2);</span><br><span class="line">            <span class="keyword">return</span> (res != <span class="number">0</span>) ? res : other.compare(c1, c2);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> Comparator&lt;T&gt; <span class="title">thenComparingInt</span><span class="params">(ToIntFunction&lt;? <span class="keyword">super</span> T&gt; keyExtractor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> thenComparing(comparingInt(keyExtractor));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>我们排序时需要实现的方法是compare。</li>
<li>equals在排序时没有用到，是从Object继承来的默认实现</li>
<li>后面省略了一些default的方法，这些方法都是jdk1.8中针对lambda实现的默认方法</li>
</ol>
<ul>
<li>使用方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">List&lt;People&gt; peopleList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        peopleList.addAll(Arrays.asList(<span class="keyword">new</span> People(<span class="string">"stalary"</span>, <span class="number">21</span>),<span class="keyword">new</span> People(<span class="string">"claire"</span>, <span class="number">20</span>),<span class="keyword">new</span> People(<span class="string">"hawk"</span>, <span class="number">19</span>)));</span><br><span class="line">        Collections.sort(peopleList, <span class="keyword">new</span> PeopleComparator());</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PeopleComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">People</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(People o1, People o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.getAge() - o2.getAge();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在jdk1.8中我们可以这样进行排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peopleList.sort(Comparator.comparing(People::getAge));</span><br></pre></td></tr></table></figure>
<p>当想要升序排序时，我们可以修改比较器中的compare或者直接调用reversed方法(1.8中实现的默认方法)</p>
<p>还可以在比较时写一个匿名内部类的比较器进行比较，但使用lambda更加方便，所以不推荐使用。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总体来看Comparator更加灵活，可以不需要对象去继承一个接口，而且在1.8引入了lambda以后使用更加方便</p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
            <category> 源码分析 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Comparable </tag>
            
            <tag> Comparator </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【剑指offer】二叉树中序遍历的下一个结点]]></title>
      <url>/2018/01/07/BinaryTreeNextNode/</url>
      <content type="html"><![CDATA[<p>二叉树中序遍历的下一个结点</p>
<ul>
<li>题目解释：</li>
</ul>
<p>找到给定的结点在中序遍历中的下一个结点，结点的结构中存在一个指向父结点的指针。</p>
<ul>
<li>样例：</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/9252736-645939fcf0242f9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>5号结点的下一个结点是1号结点，而1号结点的下一个结点是4号结点。</p>
<ul>
<li>题解：</li>
</ul>
<p>中序遍历的顺序即为左儿子，根，右儿子，所以分为以下两种情况</p>
<ol>
<li>当存在右子树时，找到右子树的最左结点。</li>
<li>当不存在右子树时，则找第一个当前节点是父节点左孩子的节点<br><img src="http://upload-images.jianshu.io/upload_images/9252736-2ade9cd082a52435.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>此时1结点的下一个结点即为4结点</li>
</ol>
<ul>
<li>code：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * GetNext</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 找到二叉树中序遍历中指定结点的下一个结点，结点中包含一个指向父结点的结点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lirongqian</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018/01/07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetNext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkNode <span class="title">GetNext</span><span class="params">(TreeLinkNode pNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当存在右子树时，找到右子树的最左结点</span></span><br><span class="line">        <span class="keyword">if</span> (pNode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pNode = pNode.right;</span><br><span class="line">            <span class="keyword">while</span> (pNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pNode = pNode.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> pNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当不存在右子树时，则找第一个当前节点是父节点左孩子的节点</span></span><br><span class="line">        <span class="keyword">while</span> (pNode.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(pNode.next.left == pNode) &#123;</span><br><span class="line">                <span class="keyword">return</span> pNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">            pNode = pNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeLinkNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeLinkNode left = <span class="keyword">null</span>;</span><br><span class="line">    TreeLinkNode right = <span class="keyword">null</span>;</span><br><span class="line">    TreeLinkNode next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    TreeLinkNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个题的主要思路就是要理解清中序遍历的顺序，理解好左-中-右的顺序，上图中的三种情况为：</p>
<ol>
<li>2-&gt;5，不存在右子树，为上一个结点的左结点</li>
<li>5-&gt;1，存在右子树</li>
<li>1-&gt;4，不存在右子树，且为上一个结点的右结点，所以要去找根结点</li>
</ol>
<p>聚沙成塔，学习非一日之功。</p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
            <category> 剑指offer </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【web】跨域丢失cookie的问题]]></title>
      <url>/2018/01/03/CORSResolveCookiesLoose/</url>
      <content type="html"><![CDATA[<p>2018年的第一篇博客，新的开始，新的起点</p>
<p>前几天在写一个利用cookie存储token的登陆demo时遇到了跨域丢失token的问题，在这里分享一下解决的方法。</p>
<h4 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h4><ul>
<li>前端使用了vue-reource的$http进行请求后台接口</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$http(&#123;</span><br><span class="line">              url: <span class="string">"http://120.24.5.178:8100/user/login"</span>,</span><br><span class="line">              method: <span class="string">"POST"</span>,</span><br><span class="line">              body: <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">                username: <span class="keyword">this</span>.ruleForm.username,</span><br><span class="line">                password: <span class="keyword">this</span>.ruleForm.password</span><br><span class="line">              &#125;),</span><br><span class="line">              headers: &#123;</span><br><span class="line">                <span class="string">"Content-Type"</span>: <span class="string">"application/json"</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>登陆完成后，服务端监控发现无法拿到cookie，下面看几张前端控制台监控的图</p>
</li>
<li><p>无法拿到cookie时的监控图<br><img src="http://upload-images.jianshu.io/upload_images/9252736-6be7f1065e84050a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="http://upload-images.jianshu.io/upload_images/9252736-f05479b3bf243d54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
</li>
<li>后台cors代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        HttpServletRequest request = (HttpServletRequest) req;</span><br><span class="line">        HttpServletResponse response = (HttpServletResponse) res;</span><br><span class="line">        String origin = request.getHeader(<span class="string">"Origin"</span>);</span><br><span class="line">        response.setHeader(<span class="string">"Access-Control-Allow-Origin"</span>, <span class="string">"*"</span>);</span><br><span class="line">        response.setHeader(<span class="string">"Access-Control-Allow-Methods"</span>,</span><br><span class="line">                <span class="string">"GET, POST, PUT, DELETE, OPTIONS"</span>);</span><br><span class="line">        response.setHeader(<span class="string">"Access-Control-Allow-Credentials"</span>, <span class="string">"true"</span>);</span><br><span class="line">        response.setHeader(<span class="string">"Access-Control-Allow-Headers"</span>,</span><br><span class="line">                <span class="string">"Origin, X-Requested-With, Content-Type, Accept, Authorization"</span>);</span><br><span class="line"></span><br><span class="line">        chain.doFilter(req, res);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>后台获取cookie的代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Cookie[] cookies = request.getCookies();</span><br><span class="line">        <span class="keyword">if</span> (cookies != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">"ticket"</span>.equals(cookie.getName())) &#123;</span><br><span class="line">                    String value = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (!StringUtils.isEmpty(cookie.getValue())) &#123;</span><br><span class="line">                        value = DigestUtil.Decrypt(cookie.getValue());</span><br><span class="line">                    &#125;</span><br><span class="line">                    User login = userService.findByTicket(value);</span><br><span class="line">                    request.getSession().setAttribute(<span class="string">"user"</span>, login);</span><br><span class="line">                    log.info(<span class="string">"ticket: "</span> + value);</span><br><span class="line">                    log.info(<span class="string">"user: "</span> + login);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>因为request中没有cookies，所以后台获取为null</p>
</li>
<li><p>经过上网查资料修改后的监控图片</p>
</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/9252736-3177695f2b63ed13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="http://upload-images.jianshu.io/upload_images/9252736-36f7d79c8afde696.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<ul>
<li>我们可以发现在request中多了cookie这个字段，并且在cookies中有了ticket，后台可以通过request.getCookies()进行获取了</li>
</ul>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ul>
<li>最后定位到了这是一个跨域问题，在跨域时cookie被丢弃。</li>
<li>前端：请求时增加withCredentials: true</li>
<li><p>后端：</p>
<ul>
<li>直接使用*来匹配所有域名只能适用于无需使用cookie的场景</li>
<li>可以将origin的*替换为允许请求的正则表达式</li>
<li><p>可以加入一个list列表，代表请求白名单</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; allowedOrigins = Arrays.asList(<span class="string">"http://localhost:8080"</span>, <span class="string">"http://localhost:8100"</span>, <span class="string">"http://login.stalary.com"</span>);</span><br><span class="line">response.setHeader(<span class="string">"Access-Control-Allow-Origin"</span>, allowedOrigins.contains(origin) ? origin : <span class="string">""</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>也可以直接拿到前端的第一次options请求的header来进行跨域处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String origin = request.getHeader(<span class="string">"Origin"</span>);</span><br><span class="line">    response.setHeader(<span class="string">"Access-Control-Allow-Origin"</span>, origin);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>本次简单的跨域丢失cookie的处理就介绍到这里了，如有问题可以私信博主qq<br><a href="http://login.stalary.com" target="_blank" rel="noopener">登陆demo地址</a><br><a href="https://github.com/stalary/SpringBootDemo" target="_blank" rel="noopener">登陆demo源码地址</a><br><a href="http://login.stalary.com/swagger-ui.html" target="_blank" rel="noopener">登陆demo-swagger接口地址</a></p>
<p>服务器是学生机，访问较慢，请见谅。</p>
<h5 id="每一次知识的积累，都是明天你微笑的源泉"><a href="#每一次知识的积累，都是明天你微笑的源泉" class="headerlink" title="每一次知识的积累，都是明天你微笑的源泉"></a>每一次知识的积累，都是明天你微笑的源泉</h5>]]></content>
      
        <categories>
            
            <category> web </category>
            
            <category> 跨域 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> web </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【Java】spring-boot从创建到部署]]></title>
      <url>/2017/12/29/SpringBootCreateAndDeploy/</url>
      <content type="html"><![CDATA[<p>今天介绍一下spring-boot这个开箱即用的框架，从创建到部署</p>
<h4 id="创建spring-boot项目"><a href="#创建spring-boot项目" class="headerlink" title="创建spring-boot项目"></a>创建spring-boot项目</h4><ul>
<li>首先点击creat new project<br><img src="http://upload-images.jianshu.io/upload_images/9252736-6712ad53584e4684.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
<li>然后点击spring initializr<br><img src="http://upload-images.jianshu.io/upload_images/9252736-72d8c214d28da82d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
<li>输入组名和项目名<br><img src="http://upload-images.jianshu.io/upload_images/9252736-b5cae959ecaeb2e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
<li>选择web<br><img src="http://upload-images.jianshu.io/upload_images/9252736-ea39a15fca6e8536.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
<li>finsh完成创建<br><img src="http://upload-images.jianshu.io/upload_images/9252736-3e319b9b5e62140e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
<li>pom.xml配置文件</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.stalary<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>createdemo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>createdemo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">goal</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>此时会发现在target目录下有了loginDemo-0.0.1-SNAPSHOT.jar文件<br><img src="http://upload-images.jianshu.io/upload_images/9252736-2318f1cf6e228489.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
<li>将这个文件上传到服务器上，服务器上要确保已经成功安装jdk。</li>
<li>使用nohup java -jar loginDemo-0.0.1-SNAPSHOT.jar即可运行项目(加nohup代表一直执行，不会停止，否则关闭就会停止项目)</li>
<li>使用tail -f nohup.out即可查看动态日志</li>
<li>或者使用java -jar loginDemo-0.0.1-SNAPSHOT.jar &gt; log.file 2&gt;&amp;1 &amp;(有时候断开与服务器连接，项目还是会停止)</li>
</ul>
<p>如果需要在项目上部署swagger，请看下面的教程</p>
<h4 id="添加swagger2"><a href="#添加swagger2" class="headerlink" title="添加swagger2"></a>添加swagger2</h4><ul>
<li>首先在pom.xml中添加两个依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>然后添加一个Sagger2配置类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.stalary;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.request.async.DeferredResult;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.ApiInfoBuilder;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.PathSelectors;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.RequestHandlerSelectors;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.ApiInfo;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spi.DocumentationType;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spring.web.plugins.Docket;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.swagger2.annotations.EnableSwagger2;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger</span>2</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Swagger2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">createRestApi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .groupName(<span class="string">"demo"</span>)</span><br><span class="line">                .genericModelSubstitutes(DeferredResult.class)</span><br><span class="line">                .useDefaultResponseMessages(<span class="keyword">false</span>)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .pathMapping(<span class="string">"/"</span>)</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">"com.stalary.controller"</span>))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ApiInfo <span class="title">apiInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfoBuilder()</span><br><span class="line">                .title(<span class="string">"登陆测试模块"</span>)</span><br><span class="line">                .description(<span class="string">"源码请访问：https://github.com/stalary/SpringBootDemo"</span>)</span><br><span class="line">                .termsOfServiceUrl(<span class="string">"stalary.com"</span>)</span><br><span class="line">                .version(<span class="string">"1.0"</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时访问<a href="http://120.24.5.178:8100/swagger-ui.html#/即可展示出页面" target="_blank" rel="noopener">http://120.24.5.178:8100/swagger-ui.html#/即可展示出页面</a><br><img src="http://upload-images.jianshu.io/upload_images/9252736-b551da445c580005.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<ul>
<li>最后提供一个博主spring-boot的demo </li>
<li><a href="https://github.com/stalary/SpringBootDemo" target="_blank" rel="noopener">https://github.com/stalary/SpringBootDemo</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> java </category>
            
            <category> spring </category>
            
        </categories>
        
        
        <tags>
            
            <tag> spring </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【计算机网络】URI和URL的区别]]></title>
      <url>/2017/12/25/URIAndURL/</url>
      <content type="html"><![CDATA[<p>今天介绍一下URI和URL的区别：</p>
<p>首先我们通过一个java的小demo来进入今天的讲解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(value = <span class="string">"/girls/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Girl <span class="title">findOneGirl</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            @PathVariable(<span class="string">"id"</span>)</span> Integer id,</span></span><br><span class="line"><span class="function">            HttpServletRequest request) </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"URL: "</span> + request.getRequestURL());</span><br><span class="line">        logger.info(<span class="string">"URI: "</span> + request.getRequestURI());</span><br><span class="line">        <span class="keyword">return</span> girlRepository.findOne(id);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们使用HttpServletRequest的request.getRequestURL和request.getRequestURI来进行比较，请求后，返回的日志为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">URL: http:<span class="comment">//localhost:8082/girls/2</span></span><br><span class="line"></span><br><span class="line">URI: /girls/<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>可以发现URL返回的是我们接口映射的地址，而URI返回的是这个接口的名字(唯一标识)</p>
<ul>
<li>URI(uniform resource identifier): 统一资源标识符，可以唯一的标识一个文件</li>
<li>URL(uniform resource locator): 统一资源定位器，是一种具体的URI，而且准确定位了这个文件的位置</li>
<li>关系：每个URL都是URI，但是URI不一定是URL，因为URI还包括URN(统一资源名称)，URI定义了这个资源是什么，URL除了定义这个资源是什么，还定义了怎样找到这个资源</li>
</ul>
<p>下面是URL和URI的关系<br><img src="http://upload-images.jianshu.io/upload_images/9252736-d901ce7f0caa68bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>下面是URL,URI,URN三者的关系<br><img src="http://ww4.sinaimg.cn/mw690/6941baebgw1evu0o8swewj20go0avq3e.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> 计算机网络 </category>
            
            <category> URI和URL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> URI和URL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【Java】ffmpeg的调用]]></title>
      <url>/2017/12/23/JavaUseFfmpeg/</url>
      <content type="html"><![CDATA[<p>今天介绍一下java如何调用ffmpeg对音频视频等进行转码，暂时只介绍一个其他格式转码到mp3的例子</p>
<h3 id="下载ffmpeg"><a href="#下载ffmpeg" class="headerlink" title="下载ffmpeg"></a>下载ffmpeg</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Mac: </span><br><span class="line">1.下载homebrew</span><br><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br><span class="line">2.下载ffmpeg</span><br><span class="line">brew ffmpeg</span><br><span class="line">3.找到ffmpeg</span><br><span class="line">文件路径：/usr/local/Cellar/ffmpeg/3.4.1/bin</span><br><span class="line"></span><br><span class="line">Windows:</span><br><span class="line">1.前往http://www.ffmpeg.org/download.html下载build文件</span><br><span class="line">2.解压文件，配置环境变量PATH，使系统可以找到该软件</span><br><span class="line">3.cmd输入ffmpeg -version查看是否安装成功</span><br><span class="line"></span><br><span class="line">linux:</span><br><span class="line">1.官网下载源码包</span><br><span class="line">2.解压源码包</span><br><span class="line">3. ./configure --enable-shared --prefix=/usr/local/ffmpeg --enable-libmp3lame(这里因为我是转mp3，所以下载了libmp3lame的编译器)</span><br><span class="line">4.make</span><br><span class="line">5.make install</span><br><span class="line">如果遇到报错，则有可能是缺少yasm的依赖，需要去下载yasm的包进行解压并编译</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如果是centos系统可以直接使用yum -y install ffmpeg，如果需要切换数据源则按如下步骤:</span><br><span class="line"></span><br><span class="line">1.安装EPEL Release，因为安装需要使用其他的repo源，所以需要EPEL支持</span><br><span class="line">yum install -y epel-release </span><br><span class="line">#如果出现缺少Code提示，可以：</span><br><span class="line">sudo rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7</span><br><span class="line">#安装完成之后，可以查看是否安装成功</span><br><span class="line">yum repolist </span><br><span class="line">2.安装Nux-Dextop源</span><br><span class="line">#导入一个Code</span><br><span class="line">sudo rpm --import http://li.nux.ro/download/nux/RPM-GPG-KEY-nux.ro </span><br><span class="line">#安装nux-dextop 源</span><br><span class="line">sudo rpm -Uvh http://li.nux.ro/download/nux/dextop/el7/x86_64/nux-dextop-release-0-1.el7.nux.noarch.rpm</span><br><span class="line">#查看repo源是否安装成功</span><br><span class="line">yum repolist </span><br><span class="line">3.yum安装ffmpeg</span><br><span class="line">yum install -y ffmpeg</span><br></pre></td></tr></table></figure>
<h3 id="通过java调用ffmpeg"><a href="#通过java调用ffmpeg" class="headerlink" title="通过java调用ffmpeg"></a>通过java调用ffmpeg</h3><ul>
<li>我们使用jave来进行操作ffmpeg</li>
<li>jave：<a href="http://www.sauronsoftware.it/projects/jave/manual.php" target="_blank" rel="noopener">http://www.sauronsoftware.it/projects/jave/manual.php</a></li>
<li>需要引入一个jar包，这里分享给大家(当时找了半天)</li>
<li>链接:<a href="https://pan.baidu.com/s/1cygkBc" target="_blank" rel="noopener">https://pan.baidu.com/s/1cygkBc</a>  密码:qpg7</li>
<li>引入的java中就可以开始使用了，下面是一个其他格式转化为mp3格式的小demo</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Stalary</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2017/10/14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        File source = <span class="keyword">new</span> File(<span class="string">"/Users/mac/Downloads/1"</span>);</span><br><span class="line">        File target = <span class="keyword">new</span> File(<span class="string">"/Users/mac/Downloads/test.mp3"</span>);</span><br><span class="line">        <span class="comment">// 设置转码后的格式</span></span><br><span class="line">        AudioAttributes audio = <span class="keyword">new</span> AudioAttributes();</span><br><span class="line">        audio.setCodec(<span class="string">"libmp3lame"</span>);</span><br><span class="line">        EncodingAttributes attrs = <span class="keyword">new</span> EncodingAttributes();</span><br><span class="line">        attrs.setFormat(<span class="string">"mp3"</span>);</span><br><span class="line">        attrs.setAudioAttributes(audio);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 这里需要注意：只有mac才需要进行指定ffmpeg路径，否则会找不到</span></span><br><span class="line">            <span class="comment">// 需要自行实现一个MyFFMPEGExecutableLocator类并继承FFMPEGLocator</span></span><br><span class="line">            <span class="comment">// 实现其中的getFFMPEGExecutablePath方法返回本机ffmpeg地址</span></span><br><span class="line">            <span class="comment">// 其他操作系统直接使用new Encoder();</span></span><br><span class="line">            Encoder encoder = <span class="keyword">new</span> Encoder(<span class="keyword">new</span> MyFFMPEGExecutableLocator());</span><br><span class="line">            encoder.encode(source, target, attrs);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException | EncoderException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFFMPEGExecutableLocator</span> <span class="keyword">extends</span> <span class="title">FFMPEGLocator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFFMPEGExecutablePath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"/usr/local/Cellar/ffmpeg/3.4.1/bin/ffmpeg"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面就是一个最基本的转码格式，具体需求可以去ffmpeg查看文档，下面说一下前端上传一个音频到获取到音频url的流程。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/9252736-09647b4235fdecee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="流程图"></p>
<p>ffmpeg的基本使用就介绍到这里啦，爬了不少坑，也学到了不少</p>
<p>每一次钻研，都是未来上升的阶梯</p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
            <category> ffmpeg </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ffmpeg </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【Java】虚拟机浅显分析]]></title>
      <url>/2017/12/19/Jvm/</url>
      <content type="html"><![CDATA[<p>普及一下虚拟机中的一些区域，垃圾收集算法，垃圾收集器等，后续还会完善</p>
<h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><ol>
<li>线程私有</li>
<li>一块较小的内存空间</li>
<li>记录正在执行的java方法的虚拟机字节码指令的地址(native方法为空)</li>
<li>没有OutOfMemoryError的情况</li>
</ol>
<h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><ol>
<li>线程私有</li>
<li>为虚拟机执行java方法服务</li>
<li>与线程的生命周期相同</li>
<li>当线程请求的栈深度大于虚拟机所允许的深度，抛出StackOverflowError，当虚拟机扩展时无法申请到足够的内存，将会抛出OutOfMemoryError</li>
<li>方法执行时创建的栈帧用于存储局部变量表，操作数栈，动态链接，方法出口</li>
<li>方法调用时分配栈帧，离开时撤销栈帧</li>
<li><p>局部变量表：</p>
<ul>
<li>存放基本数据类型</li>
<li>对象引用</li>
</ul>
</li>
</ol>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><ol>
<li>为虚拟机执行native方法服务</li>
<li>和虚拟机栈相同，会抛出StackOverflowError和OutOfMemoryError</li>
</ol>
<h4 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h4><ol>
<li>线程共享</li>
<li>内存中最大的一块</li>
<li>存放对象实例以及数组</li>
<li>垃圾收集器管理的主要区域(GC堆)</li>
<li>堆中分为新生代和老年代</li>
<li>堆无法再扩展时，抛出OutOfMemoryError</li>
</ol>
<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><ol>
<li>线程共享</li>
<li>存储已被虚拟机加载的类信息，常量，静态变量，编译器编译后的代码</li>
<li>方法区无法满足内存需求时抛出OutOfMemoryError</li>
<li>使用永久代实现</li>
</ol>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><ol>
<li>方法区的一部分</li>
<li>存储字面量和符号引用</li>
<li>无法再申请到内存时抛出OutOfMemoryError</li>
</ol>
<h2 id="对象的访问"><a href="#对象的访问" class="headerlink" title="对象的访问"></a>对象的访问</h2><h4 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h4><ol>
<li>引用存储对象的句柄地址</li>
<li>对象被修改时只会改变句柄中的实例数据指针，引用本身不改变</li>
</ol>
<h4 id="直接指针访问"><a href="#直接指针访问" class="headerlink" title="直接指针访问"></a>直接指针访问</h4><ol>
<li>引用存储对象的地址</li>
<li>速度更快，Sun HotSpot虚拟机中使用</li>
</ol>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h4 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h4><ol>
<li>不断创建对象实例并且GC Roots到对象之间有可达路径避免垃圾回收时会产生(OOME Java heap space)</li>
</ol>
<h4 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h4><ol>
<li>栈深度大于虚拟机所允许的深度(SOE)</li>
<li>虚拟机扩展时无法申请到足够的内存</li>
<li>多线程下导致的内存溢出，可以通过减少最大堆和减少栈容量来换取更多的线程(OOME)</li>
</ol>
<h4 id="方法区和运行时常量池溢出"><a href="#方法区和运行时常量池溢出" class="headerlink" title="方法区和运行时常量池溢出"></a>方法区和运行时常量池溢出</h4><ol>
<li>产生大量的动态类(OOME PermGen space)</li>
</ol>
<h2 id="判断对象是否已经死亡"><a href="#判断对象是否已经死亡" class="headerlink" title="判断对象是否已经死亡"></a>判断对象是否已经死亡</h2><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><ol>
<li>有一个地方引用，计数器加1，引用失效时减1，当为0时即代表不可能被使用</li>
<li>缺点是无法解决循环引用的问题<br>A.instance = B;B.instance = A。两个对象都已经不可能被访问</li>
</ol>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><ol>
<li>GC Roots对象作为起点，判断是否存在路径(引用链)可以到达对象</li>
<li><p>可以作为GC Roots的对象有：</p>
<ul>
<li>虚拟机栈中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>native方法引用的对象</li>
</ul>
</li>
</ol>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A a = <span class="keyword">new</span> A();</span><br></pre></td></tr></table></figure>
<p>只要强引用存在，垃圾回收器永远不会回收被引用的对象</p>
<h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><ol>
<li>有用但非必需的对象</li>
<li>在将要发生内存溢出之前，进行回收，这次回收内存还没有足够的内存，才会抛出异常</li>
<li>使用SoftReference来实现</li>
</ol>
<h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><ol>
<li>非必需对象</li>
<li>只能生存到下一次垃圾收集发生之前</li>
<li>使用WeakReference来实现</li>
</ol>
<h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><ol>
<li>无法获得对象实例</li>
<li>唯一目的是被垃圾回收时收到一个系统通知</li>
<li>使用PhantomReference来实现</li>
</ol>
<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><ol>
<li>首先标记需要回收的对象</li>
<li>清除标记的对象</li>
<li>缺点是会产生大量不连续的内存碎片，当需要分配较大对象时，会提前触发另一次垃圾回收</li>
</ol>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><ol>
<li>将内存按容量划分为大小相等的两块，每次只使用其中的一块，使用完成后将存活的对象复制到另一块，然后清理使用过的内存空间</li>
<li>缺点是浪费内存</li>
</ol>
<h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><ol>
<li>首先标记需要回收的对象</li>
<li>将所有存活的对象向一端移动</li>
<li>清理掉边界以外的内存</li>
</ol>
<h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><ol>
<li>分为新生代和老年代进行收集</li>
<li>新生代每次都有大批对象死去，可以选用复制算法，老年代中对象存活率高，使用标记-清除算法或者标记-整理算法</li>
</ol>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h4 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h4><ol>
<li>单线程收集器，垃圾收集时，需停止其他的所有工作线程(Stop The World)</li>
<li>在Client模式下时很好的选择</li>
<li>新生代采用复制算法，老年代采用标记-整理算法</li>
<li>由于单线程的环境，所以简单高效</li>
<li>新生代收集器</li>
</ol>
<h4 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h4><ol>
<li>Serial收集器的老年代版本</li>
<li>在jdk1.5之前和Parallel Scavenge收集器搭配使用(1.5之后才有Parallel Old收集器)。</li>
<li>作为CMS收集器的后备预案(发生Concurrent Mode Failure时使用)</li>
<li>老年代收集器</li>
</ol>
<h4 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h4><ol>
<li>Serial收集器的多线程版本</li>
<li>新生代采用复制算法，老年代采用标记-整理算法</li>
<li>与CMS收集器搭配使用</li>
<li>并发收集器</li>
<li>新生代收集器</li>
</ol>
<h4 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h4><ol>
<li>吞吐量优先</li>
<li>可以直接设置最大垃圾收集停顿时间(缩短停顿时间，同时也会缩短停顿间隔，减小吞吐量)和吞吐量(代码运行时间/代码运行时间+垃圾回收时间)大小</li>
<li>可以使用自适应的调节策略来控制停顿时间和吞吐量(与ParNew的主要区别)</li>
<li>年轻代收集器</li>
<li>多线程</li>
</ol>
<h4 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h4><ol>
<li>多线程</li>
<li>老年代收集器</li>
<li>jdk1.6中开始提供</li>
</ol>
<h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h4><ol>
<li>停顿时间最短化</li>
<li><p>分为四个步骤:</p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>重新标记</li>
<li>并发清除</li>
</ul>
</li>
</ol>
<p>初始标记和重新标记需要Stop The World但是时间并不长，剩下两个步骤可以和用户线程并发执行</p>
<ol>
<li>基于标记-清除(注意)，会产生大量的内存碎片</li>
<li>缺点是并发占用一部分用户线程，造成吞吐量降低应用程序变慢，无法处理浮动垃圾(垃圾回收时产生的垃圾)</li>
</ol>
<h4 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h4><ol>
<li>分代收集</li>
<li>使用多个cpu并行执行垃圾回收(缩短Stop The World的时间)，通过并发使其他线程和垃圾回收线程一起执行</li>
<li>整体上标记-整理算法，局部上基于复制算法</li>
<li>可预测何时停顿以及停顿时间，通过后台维护一个垃圾回收优先列表来实现</li>
<li>与其他收集器不同，不再以新生代和老年代做区分，而是划分为多个大小相同的区域。</li>
<li>通过Remembered Set来避免全堆扫描</li>
<li><p>分为四个步骤：</p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>最终标记</li>
<li>筛选回收</li>
</ul>
</li>
</ol>
<hr>
<p>每一本书，都是我们升华的阶梯</p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
            <category> 虚拟机 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 虚拟机 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【Java】并发工具包之CountDownLatch|CyclicBarrier|Semaphore]]></title>
      <url>/2017/12/14/ConcurrentUtils/</url>
      <content type="html"><![CDATA[<p>在java的并发包中为我们提供了三种并发控制的手段，他们分别是CountDownLatch|CyclicBarrier|Semaphore，今天我们分别来讲解一下这三种方法以及使用场景</p>
<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><ul>
<li>特点：<ul>
<li>首先设置一个计数器，在线程完成数达到计数器阈值之前，其他的一个或多个线程都会等待。</li>
<li>计数器无法重置，一旦到达阈值，就会释放所有线程</li>
</ul>
</li>
<li>适用场景：<ul>
<li>实现并行(可以用来模拟高并发的操作)</li>
<li>开始执行任务前先完成前置的一些任务</li>
<li>检测死锁</li>
</ul>
</li>
<li>使用：<ul>
<li>当每次线程完成时在执行countDown()使计数器减1，当执行线程数达到计数器阈值时即会自动释放所有等待的线程</li>
</ul>
</li>
<li>demo：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> THREAD_COUNT = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 初始化，设置计数器大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(THREAD_COUNT);</span><br><span class="line">    <span class="comment">// 创建线程池，大小与计数器一致，不一致则无法实现一次并发所有请求</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService ex = Executors.newFixedThreadPool(THREAD_COUNT);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREAD_COUNT; i++) &#123;</span><br><span class="line">            Runnable runnable = () -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    System.out.println(<span class="string">"Thread: "</span> + Thread.currentThread().getName());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 一个线程执行完毕，计数器减1</span></span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">// 线程池执行线程</span></span><br><span class="line">            ex.execute(runnable);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        ex.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">after <span class="number">1</span>s output：</span><br><span class="line"></span><br><span class="line">Thread: pool-<span class="number">1</span>-thread-<span class="number">8</span></span><br><span class="line">Thread: pool-<span class="number">1</span>-thread-<span class="number">3</span></span><br><span class="line">Thread: pool-<span class="number">1</span>-thread-<span class="number">7</span></span><br><span class="line">Thread: pool-<span class="number">1</span>-thread-<span class="number">10</span></span><br><span class="line">Thread: pool-<span class="number">1</span>-thread-<span class="number">5</span></span><br><span class="line">Thread: pool-<span class="number">1</span>-thread-<span class="number">2</span></span><br><span class="line">Thread: pool-<span class="number">1</span>-thread-<span class="number">6</span></span><br><span class="line">Thread: pool-<span class="number">1</span>-thread-<span class="number">4</span></span><br><span class="line">Thread: pool-<span class="number">1</span>-thread-<span class="number">9</span></span><br><span class="line">Thread: pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><ul>
<li>特点：<ul>
<li>设置屏障，当一组线程到达屏障时被阻塞，待所有线程到达时，取消所有阻塞。</li>
</ul>
</li>
<li>适用场景：<ul>
<li>需要所有子任务完成时才执行主任务(类似CountDownLatch)</li>
<li>多线程计算，最后合并计算结果</li>
</ul>
</li>
<li>使用：<ul>
<li>每次执行完线程，调用await()进入屏障中等待</li>
<li>当所有线程都到达屏障时，自动取消所有阻塞</li>
</ul>
</li>
<li>demo：</li>
</ul>
<p>设置多名学生，求多个学生的平均成绩，如果使用多线程计算每个学生的成绩，则需要等待所有学生的成绩计算完毕，才能求平均值，所以可以使用CyclicBarrier    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程池数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_COUNT = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建屏障数量，屏障全部到达后执行当前类的run方法</span></span><br><span class="line">    <span class="keyword">private</span> CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程池</span></span><br><span class="line">    <span class="keyword">private</span> Executor executor = Executors.newFixedThreadPool(THREAD_COUNT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存每个人的成绩</span></span><br><span class="line">    <span class="keyword">private</span> ConcurrentHashMap&lt;String, Integer&gt; scores = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CyclicBarrierDemo c = <span class="keyword">new</span> CyclicBarrierDemo();</span><br><span class="line">        c.count();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            Runnable runnable = () -&gt; &#123;</span><br><span class="line">                <span class="comment">// 每个学生的随机成绩</span></span><br><span class="line">                <span class="keyword">int</span> temp = random.nextInt(<span class="number">100</span>);</span><br><span class="line">                scores.put(Thread.currentThread().getName(), temp);</span><br><span class="line">                System.out.println(temp);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 进入屏障，等待其他学生计算完毕</span></span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            executor.execute(runnable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 求平均值</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; out : scores.entrySet()) &#123;</span><br><span class="line">            result += out.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"avg: "</span> + result / THREAD_COUNT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">output:</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">76</span></span><br><span class="line"><span class="number">98</span></span><br><span class="line"><span class="number">37</span></span><br><span class="line">avg: <span class="number">45</span></span><br></pre></td></tr></table></figure>
<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><ul>
<li>特点：<ul>
<li>设置同一时间被访问的线程数量，可以实现流量控制</li>
</ul>
</li>
<li>适用场景：<ul>
<li>限流，限制每次运行的线程数量</li>
</ul>
</li>
<li>使用：<ul>
<li>线程开始时调用acquire()使用一个信号量</li>
<li>线程结束时调用semaphore.release()释放一个信号量</li>
<li>当acquire()-release()&gt;Semaphore时，则无法再开始新的线程</li>
</ul>
</li>
<li>demo：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> THREAD_COUNT = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程池大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService exec = Executors.newFixedThreadPool(THREAD_COUNT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置信号量的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(THREAD_COUNT);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> No = i;</span><br><span class="line">            Runnable runnable = () -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(<span class="string">"Get: "</span> + No);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            exec.execute(runnable);</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">every <span class="number">5</span>s output <span class="number">5</span>:</span><br><span class="line">Get: <span class="number">1</span></span><br><span class="line">Get: <span class="number">3</span></span><br><span class="line">Get: <span class="number">4</span></span><br><span class="line">Get: <span class="number">2</span></span><br><span class="line">Get: <span class="number">0</span></span><br><span class="line">Get: <span class="number">5</span></span><br><span class="line">Get: <span class="number">6</span></span><br><span class="line">Get: <span class="number">7</span></span><br><span class="line">Get: <span class="number">8</span></span><br><span class="line">Get: <span class="number">9</span></span><br><span class="line">Get: <span class="number">10</span></span><br><span class="line">Get: <span class="number">12</span></span><br><span class="line">Get: <span class="number">11</span></span><br><span class="line">Get: <span class="number">13</span></span><br><span class="line">Get: <span class="number">17</span></span><br><span class="line">Get: <span class="number">15</span></span><br><span class="line">Get: <span class="number">14</span></span><br><span class="line">Get: <span class="number">16</span></span><br><span class="line">Get: <span class="number">19</span></span><br><span class="line">Get: <span class="number">18</span></span><br><span class="line">Get: <span class="number">20</span></span><br><span class="line">Get: <span class="number">22</span></span><br><span class="line">Get: <span class="number">21</span></span><br><span class="line">Get: <span class="number">23</span></span><br><span class="line">Get: <span class="number">24</span></span><br><span class="line">Get: <span class="number">26</span></span><br><span class="line">Get: <span class="number">25</span></span><br><span class="line">Get: <span class="number">29</span></span><br><span class="line">Get: <span class="number">28</span></span><br><span class="line">Get: <span class="number">27</span></span><br><span class="line">Get: <span class="number">30</span></span><br><span class="line">Get: <span class="number">33</span></span><br><span class="line">Get: <span class="number">36</span></span><br><span class="line">Get: <span class="number">38</span></span><br><span class="line">Get: <span class="number">39</span></span><br><span class="line">Get: <span class="number">32</span></span><br><span class="line">Get: <span class="number">31</span></span><br><span class="line">Get: <span class="number">37</span></span><br><span class="line">Get: <span class="number">35</span></span><br><span class="line">Get: <span class="number">34</span></span><br><span class="line">Get: <span class="number">40</span></span><br><span class="line">Get: <span class="number">45</span></span><br><span class="line">Get: <span class="number">49</span></span><br><span class="line">Get: <span class="number">44</span></span><br><span class="line">Get: <span class="number">43</span></span><br><span class="line">Get: <span class="number">42</span></span><br><span class="line">Get: <span class="number">41</span></span><br><span class="line">Get: <span class="number">48</span></span><br><span class="line">Get: <span class="number">47</span></span><br><span class="line">Get: <span class="number">46</span></span><br></pre></td></tr></table></figure>
<p>三种工具的使用方法就介绍的这里，源码分析待日后分析。。。。</p>
<p>每一行代码，都是浩瀚星辰的点点繁星</p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
            <category> 并发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【剑指offer】顺时针打印矩阵]]></title>
      <url>/2017/12/12/SwordOfferPrintMatrix/</url>
      <content type="html"><![CDATA[<p>顺时针打印矩阵</p>
<ul>
<li>题目解释：</li>
</ul>
<p>输入一个矩阵，按照从外到内的顺序打印才出来。</p>
<ul>
<li>样例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">input:</span><br><span class="line">1  2  3  4</span><br><span class="line">5  6  7  8</span><br><span class="line">9  10 11 12</span><br><span class="line">13 14 15 16</span><br><span class="line">output:</span><br><span class="line">1 2 3 4 8 12 16 15 14 13 9 5 6 7 11 10</span><br></pre></td></tr></table></figure>
<ul>
<li>题解：</li>
</ul>
<p>首先我的思路是用变量来控制遍历的移动，后来发现行不通，所以用了网上的常规方法，首先求出层数，这个可以决定一共需要遍历多少圈，然后再分别进行四个方向的移动。求层数是有固定的公式的:<br>(min(行，列)-1)/2 + 1。我们只需要找到四个边角的规律。</p>
<ul>
<li>code：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span> (matrix.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> m = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//层数</span></span><br><span class="line">        <span class="keyword">int</span> layers = (Math.min(n, m) - <span class="number">1</span>) / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; layers; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt; m - i; k++) &#123;</span><br><span class="line">                <span class="comment">//从左至右，行不变，列增加</span></span><br><span class="line">                result.add(matrix[i][k]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n - i; j++) &#123;</span><br><span class="line">                <span class="comment">//右上至右下，列不变，行增加</span></span><br><span class="line">                result.add(matrix[j][m - i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = m - i - <span class="number">2</span>; (k &gt;= i) &amp;&amp; (n - i - <span class="number">1</span> != i); k--) &#123;</span><br><span class="line">                <span class="comment">//从右至左，行不变，列减小，注意边界</span></span><br><span class="line">                result.add(matrix[n - i - <span class="number">1</span>][k]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n - i - <span class="number">2</span>; (j &gt; i) &amp;&amp; (m - i - <span class="number">1</span> != i); j--) &#123;</span><br><span class="line">                <span class="comment">//左下至左上，列不变，行减小，注意边界</span></span><br><span class="line">                result.add(matrix[j][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
            <category> 剑指offer </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【剑指offer】链表中环的入口结点]]></title>
      <url>/2017/12/09/SwordOfferEntrance/</url>
      <content type="html"><![CDATA[<p>链表中环的入口结点</p>
<ul>
<li>题目解释：</li>
</ul>
<p>找到一个带环的链表中环的入口结点</p>
<ul>
<li><p>样例：<br><img src="http://upload-images.jianshu.io/upload_images/9252736-10dfbd7547961aae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>此时的入口结点就是3结点</p>
</li>
<li><p>题解：</p>
</li>
</ul>
<p>这个题的思路是我们可以使用一对快慢指针：</p>
<ol>
<li>首先快指针移动两个结点，慢指针移动一个结点，当两个结点相遇时就可以知道链表是否存在环。</li>
<li>然后返回相遇的点，再进行设置两个指针，第一个指针从相遇点开始向后移动，并统计结点的数量，当再次相遇时即可获得环中元素的数量。</li>
<li>最后使第二个指针从头开始移动，第一个指针也随之移动，当和第一个指针相遇时即找到了入口结点  </li>
</ol>
<ul>
<li>code：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用一对快慢指针来判断是否有环，快指针每次移动2，慢指针每次移动1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pHead</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">meetNode</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="keyword">null</span> || pHead.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = pHead.next;</span><br><span class="line">        ListNode fast = slow.next;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; slow != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">                <span class="keyword">return</span> fast;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            <span class="keyword">if</span> (fast != slow) &#123;</span><br><span class="line">                fast = fast.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从相遇点向后移动，当再次回到这个点的时候，就能统计出环中元素的数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pHead</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">entryNodeOfLoop</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">        ListNode meetNode = meetNode(pHead);</span><br><span class="line">        <span class="keyword">if</span> (meetNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        ListNode p1 = meetNode;</span><br><span class="line">        <span class="keyword">while</span> (p1.next != meetNode) &#123;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        p1 = pHead;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode p2 = pHead;</span><br><span class="line">        <span class="keyword">while</span> (p2 != p1) &#123;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        ListNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
            <category> 剑指offer </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【leetcode】409题解]]></title>
      <url>/2017/12/09/leetcode409/</url>
      <content type="html"><![CDATA[<p>Longest Palindrome</p>
<ul>
<li>题目描述：</li>
</ul>
<p>给定一个包含小写字母和大写字母的字符串，统计字符串中的字符所能组成的回文子串的最长的长度。</p>
<ul>
<li>样例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">&quot;abccccdd&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">7</span><br></pre></td></tr></table></figure>
<ul>
<li>题解：</li>
</ul>
<p>回文即代表正反遍历是相同的，所以我们可以使用一个HashMap或者HashSet来进行存储每个字符出现数量。</p>
<ul>
<li>code：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> a = s.charAt(i);</span><br><span class="line">            map.put(a, map.getOrDefault(a, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> a : map.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((map.get(a) &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                sum += map.get(a) - <span class="number">1</span>;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum += map.get(a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            sum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
            <category> leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 集合 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【剑指offer】调整数组顺序使奇数位于偶数前面]]></title>
      <url>/2017/12/07/SwordOfferAdjustOrder/</url>
      <content type="html"><![CDATA[<p>调整数组顺序使奇数位于偶数前面</p>
<ul>
<li>题目描述：</li>
</ul>
<p>给定一个数组，如果奇数位于偶数前面，则交换位置，并且要保证偶数和偶数之间的相对位置是不改变的</p>
<ul>
<li>样例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">input:</span><br><span class="line">[1, 2, 3, 9, 4]</span><br><span class="line">output:</span><br><span class="line">[1, 3, 9, 2, 4]</span><br></pre></td></tr></table></figure>
<ul>
<li>题解：</li>
</ul>
<p>这个题可以找到两种思路：</p>
<ul>
<li>在原数组中进行改变位置，当奇数在偶数后面时就进行移动</li>
<li>新开辟一个数组，重新进行组装</li>
</ul>
<ul>
<li>code：</li>
</ul>
<pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>{
        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(array.length);
        <span class="keyword">for</span> (<span class="keyword">int</span> n : array) {
            <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) {
                list.add(n);
            }
        }
        <span class="keyword">for</span> (<span class="keyword">int</span> n : array) {
            <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">0</span>) {
                list.add(n);
            }
        }
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) {
            array[i] = list.get(i);
        }
    }

    <span class="comment">/**</span>
<span class="comment">     * 利用类似于插入排序的思想，如果存在偶数在奇数后面，就一直向前移动</span>
<span class="comment">     * <span class="doctag">@param</span> array</span>
<span class="comment">     */</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray1</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>{
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) {
            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; array[j] % <span class="number">2</span> == <span class="number">1</span> &amp;&amp; array[j - <span class="number">1</span>] % <span class="number">2</span> == <span class="number">0</span>; j--) {
                <span class="keyword">int</span> temp = array[j];
                array[j] = array[j - <span class="number">1</span>];
                array[j - <span class="number">1</span>] = temp;
            }
        }
    }
</code></pre>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
            <category> 剑指offer </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【leetcode】697题解]]></title>
      <url>/2017/12/06/leetcode697/</url>
      <content type="html"><![CDATA[<ul>
<li>题目描述：</li>
</ul>
<p>给定一个非负数的数组，查找出现次数最多的元素(可能不止一个)，然后求出元素第一次出现和最后一次出现的最小差。</p>
<ul>
<li>样例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,2,3,1,4,2]</span><br><span class="line">Output: 6</span><br><span class="line"></span><br><span class="line">Input: [1, 2, 2, 3, 1]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>
<ul>
<li>题解：</li>
</ul>
<p>看到找出现次数最多的元素，我们可以使用map，但是这里会出现一个问题，我们需要维护一个初始位置，还需要维护一个结束位置，还有一个出现次数，所以map中值应该存储的是一个含有三个元素的数组</p>
<ul>
<li>code：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findShortestSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        Map&lt;Integer, <span class="keyword">int</span>[]&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(nums[i])) &#123;</span><br><span class="line">                map.get(nums[i])[<span class="number">0</span>]++;</span><br><span class="line">                map.get(nums[i])[<span class="number">2</span>] = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">                arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                arr[<span class="number">1</span>] = i;</span><br><span class="line">                arr[<span class="number">2</span>] = i;</span><br><span class="line">                map.put(nums[i], arr);</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(max, map.get(nums[i])[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : map.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (max == map.get(n)[<span class="number">0</span>]) &#123;</span><br><span class="line">                min = Math.min(min, map.get(n)[<span class="number">2</span>] - map.get(n)[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
            <category> leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> Map </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【leetcode】242题解]]></title>
      <url>/2017/12/05/leetcode242/</url>
      <content type="html"><![CDATA[<ul>
<li>题目描述：</li>
</ul>
<p>输入两个字符串s，t判断这两个字符串是否含有相同的元素，若相同则返回true，否则，返回false。</p>
<ul>
<li>样例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">input:</span><br><span class="line">s = &quot;anagram&quot;, t = &quot;nagaram&quot;</span><br><span class="line">output:</span><br><span class="line">true</span><br><span class="line"></span><br><span class="line">input:</span><br><span class="line">s = &quot;ab&quot;, t = &quot;a&quot;</span><br><span class="line">output:</span><br><span class="line">false</span><br></pre></td></tr></table></figure>
<ul>
<li>题解：</li>
</ul>
<p>遇到这种找相同元素的题，首先我们会想到打表的思想，而这次在讨论中又发现了一种将元素重排序，然后进行比较查看是否相同的方法，下面给出三种代码进行展示，第一种是我一开始的思路，速度较慢</p>
<ul>
<li>code：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() != t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(c)) &#123;</span><br><span class="line">                map.put(c, map.get(c) + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(c, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = t.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(t.charAt(i))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(c, map.get(c) - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.get(s.charAt(i)) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过打表的方法来判断是否t由s组成</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram1</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] alphabet = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            alphabet[s.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">            alphabet[t.charAt(i) - <span class="string">'a'</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : alphabet) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过转化为数组，进行排序后看是否元素相同来判断</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram2</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] arr1 = s.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] arr2 = t.toCharArray();</span><br><span class="line">        Arrays.sort(arr1);</span><br><span class="line">        Arrays.sort(arr2);</span><br><span class="line">        <span class="keyword">return</span> Arrays.equals(arr1, arr2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
            <category> leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【剑指offer】变态跳]]></title>
      <url>/2017/12/04/SwordOfferJump/</url>
      <content type="html"><![CDATA[<p>变态跳</p>
<ul>
<li>题目描述：</li>
</ul>
<p>一只青蛙一次可以跳上1级，也可以2级…也可以n级台阶，求青蛙跳上一个n级的台阶有多少种跳法</p>
<ul>
<li>样例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">input：</span><br><span class="line">4</span><br><span class="line">output：</span><br><span class="line">8</span><br></pre></td></tr></table></figure>
<ul>
<li>题解：</li>
</ul>
<p>我们可以先将前几项列出进行找规律</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 -&gt; 1</span><br><span class="line">2 -&gt; 2</span><br><span class="line">3 -&gt; 4</span><br><span class="line">4 -&gt; 8</span><br></pre></td></tr></table></figure>
<p>由此可以发现每次的跳法都是所有之前跳法的和，即</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f(n) = f(n-1) + f(n-2) + ... + f(1);</span><br><span class="line">f(n-1) = f(n-2) + f(n-3) + ... + f(1);</span><br><span class="line">f(n) - f(n-1) = f(n-1);</span><br><span class="line">-&gt; f(n) = 2 * f(n-1);</span><br></pre></td></tr></table></figure>
<p>所以这是一道简单的动态规划题目</p>
<ul>
<li>code:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = <span class="number">2</span> * arr[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
            <category> 剑指offer </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【leetcode】530题解]]></title>
      <url>/2017/12/04/leetcode530/</url>
      <content type="html"><![CDATA[<p>Minimum Absolute Difference in BST</p>
<ul>
<li>题目描述：</li>
</ul>
<p>给定一棵二叉搜索树，计算两个节点之间差值的最小值</p>
<ul>
<li>样例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     3</span><br><span class="line">    /</span><br><span class="line">   2</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<ul>
<li>题解：</li>
</ul>
<p>二叉搜索树的特点时左子树小于根，右子树大于根，所以当我们进行中序遍历时，就是一个升序的序列。所以这个题我们可以采用中序遍历的方法来进行解答。</p>
<ul>
<li>code：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Integer pre = <span class="keyword">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinimumDifference1</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">    getMinimumDifference1(root.left);</span><br><span class="line">    <span class="keyword">if</span> (pre != <span class="keyword">null</span>) &#123;</span><br><span class="line">        min = Math.min(min, root.val - pre);</span><br><span class="line">    &#125; <span class="comment">// 此处相当于中序遍历的打印，暂时将较小值存储在min中</span></span><br><span class="line">    pre = root.val;</span><br><span class="line">    getMinimumDifference1(root.right);</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
            <category> leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【mysql】桶思想的应用]]></title>
      <url>/2017/12/02/BucketForMysql/</url>
      <content type="html"><![CDATA[<p>原来一直没有想过数组是可以存到mysql中的，当今天真正使用时，才发现了桶思想的强大之处。</p>
<ul>
<li>什么是桶思想呢？</li>
</ul>
<p>桶排序大家一定都知道，这是一个牺牲了空间，来将时间复杂度降低到了线性的算法，而它的特点就是先划分出一定数量的桶，然后再将数字映射到各自的桶中，再对非空桶进行快速排序。</p>
<ul>
<li>何时会用到这种思想呢？</li>
</ul>
<p>例如我们我们需要统计一组数据时，其实使用一个字段就可以实现，例如我们需要统计一套试卷的答题情况，其实我们可以设置100个桶，每个学生的分数即对应桶。</p>
<p>而且当我们只需要确定一个状态时，就可以使用0或1来表示，可以使用bitmap，例如男女，已毕业未毕业这种非反即正的问题。</p>
<ul>
<li><p>java中如何存储数组和取出？</p>
<ul>
<li>可以直接将数组转化为二进制进行存储</li>
<li>先转化为字符串再进行存储，取出时再反序列化</li>
<li>我使用的是gson的转化方法，序列化与反序列化十分方便</li>
</ul>
</li>
<li><p>demo</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transient</span></span><br><span class="line"><span class="keyword">private</span> List&lt;Integer&gt; scores;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Column</span>(name = <span class="string">"scoreStr"</span>)</span><br><span class="line"><span class="keyword">private</span> String scoreStr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serializeFields</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.scoreStr = BeansFactory.getGson().toJson(scores);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deserializeFields</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.scores = BeansFactory.getGson().fromJson(scoreStr, <span class="keyword">new</span> TypeToken&lt;List&lt;Integer&gt;&gt;()&#123;&#125;.getType());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的@Transient注解是为了防止被序列化，我们将元素存入list中，然后再序列化为字符串，持久化到数据库中即可完成数据的存储，当我们需要使用数据时，只需要将字符串反序列化为list，就可以读取数据。</p>
<hr>
<p>数据库还有很多的思想等待我们去发现，去挖掘，项目中我们所需要学习的并不是一些前沿框架的使用，而是一些优秀的优化思想。</p>
<h4 id="大道至简，知易行难"><a href="#大道至简，知易行难" class="headerlink" title="大道至简，知易行难"></a>大道至简，知易行难</h4>]]></content>
      
        <categories>
            
            <category> 数据库 </category>
            
            <category> mysql </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【leetcode】349题解]]></title>
      <url>/2017/11/30/leetcode349/</url>
      <content type="html"><![CDATA[<p>Intersection of Two Arrays</p>
<ul>
<li>题目描述：</li>
</ul>
<p>给出两个数组，选出两个数组中相同的元素，存入数组中，数组中的元素不能重复。</p>
<ul>
<li>样例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">input: </span><br><span class="line">nums1 = [1, 2, 2, 1]</span><br><span class="line">nums2 = [2, 2]</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">nums3 = [2]</span><br></pre></td></tr></table></figure>
<ul>
<li>题解：</li>
</ul>
<p>熟悉java的人，一看到这种去除重复元素的题一般都会想到Set，我也不例外，使用了两个set来进行存储。</p>
<ul>
<li>code</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] intersection(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; temp = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums1.length &gt;= nums2.length) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> n : nums1) &#123;</span><br><span class="line">                set.add(n);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> n : nums2) &#123;</span><br><span class="line">                <span class="keyword">if</span> (set.contains(n)) &#123;</span><br><span class="line">                    temp.add(n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> n : nums2) &#123;</span><br><span class="line">                set.add(n);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> n : nums1) &#123;</span><br><span class="line">                <span class="keyword">if</span> (set.contains(n)) &#123;</span><br><span class="line">                    temp.add(n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] out = <span class="keyword">new</span> <span class="keyword">int</span>[temp.size()];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Integer n : temp) &#123;</span><br><span class="line">            out[i++] = n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>今天是个值得纪念的日子，终于刷完了leetcode的一页水题。</p>
<p>刷题之路漫漫兮，唯知识方可悦己之颜尔。</p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
            <category> leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 集合，set </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【java】集合常用api]]></title>
      <url>/2017/11/30/JavaCollections/</url>
      <content type="html"><![CDATA[<h1 id="常用api"><a href="#常用api" class="headerlink" title="常用api"></a>常用api</h1><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><blockquote>
<p>ArrayList是基于数组实现的动态数组，允许存在重复元素，这点要与HashMap和HashMap进行区分，我们首先要想到数组的一些特点：</p>
<ol>
<li>对于get，set的随机访问速度较快</li>
<li>添加删除元素的速度较慢，因为需要移动元素</li>
</ol>
<p>我们还要注意一个细节Arrays.asList所返回的并不是一个真正的List,我们是无法对它进行add操作的。</p>
<p>常用方法的分析：</p>
<ol>
<li>add：当传入index时，会在指定的index后面添加元素，当不指定时默认在末尾进行添加。</li>
<li>get：获取第index个的元素值</li>
<li>contains：查看list中是否存在该元素，存在则返回true。</li>
<li>set：这个方法可以与传入index的add方法进行区分，它会直接将index的元素修改为传入的元素</li>
<li>remove：删除一个末尾的元素</li>
</ol>
</blockquote>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><blockquote>
<p>LinkedList是基于链表实现的，所以我们要想到链表的一些特点</p>
<ol>
<li>随机访问速度较慢，因为要移动指针</li>
<li>添加删除元素的速度较快</li>
</ol>
<p>LinkedList经常呗作为堆栈，队列或者双向队列来使用</p>
<p>常用方法的分析：</p>
<ol>
<li>getFirst: 获取第一个元素，当为空时会抛出异常</li>
<li>removeFirst: 移除第一个元素，为空时抛出异常</li>
<li>addFirst: 添加第一个元素</li>
<li>peek: 只查看第一个元素，但不删除，为空时返回null，不会抛出异常</li>
<li>poll: 查看第一个元素，并删除，为空时返回null，与peek进行区分</li>
<li>pop: 查看第一个元素，并弹出，为空时会抛出异常，与poll进行区分</li>
<li>offer: 向末尾添加一个元素</li>
</ol>
</blockquote>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><blockquote>
<p>HashMap用来存储键值对，不允许存在重复的键，并通过链地址法来解决hash冲突，1.8中做了红黑树的优化。</p>
<p>与HashTable进行比较，HashMap是线程不安全的，而且可以接受null的键值，可以使用ConcurrentHashMap来进行同步。</p>
<p>做题时我们可以使用HashMap来做键值对映射，实现打表的方法。</p>
</blockquote>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><blockquote>
<p>HashSet会对元素自动进行去重，我们可以使用HashSet来输出一个不重复的数组，可以通过contains的方法来判断是否已存在该元素</p>
<p>HashSet和HashMap都是通过equals和hashCode</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> java </category>
            
            <category> api </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 集合 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【leetcode】122题解]]></title>
      <url>/2017/11/29/leetcode122/</url>
      <content type="html"><![CDATA[<p>Best Time to Buy and Sell Stock II</p>
<ul>
<li>题目描述：</li>
</ul>
<p>给出一个字符串，代表每天股票的价格，每天需要先卖出一次再买入，求当买入卖出次数尽量大时的利润</p>
<ul>
<li>样例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">input:</span><br><span class="line">2,3,5,1,7</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">9</span><br></pre></td></tr></table></figure>
<ul>
<li>题解：</li>
</ul>
<p>既然是求最大利润，那我们就要避免亏损的股票，所以我们可以对相邻两天的股价作差，当后一天股价较高时即盈利，然后我们将每天的盈利相加，即得到了最大的盈利</p>
<ul>
<li>code：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i + <span class="number">1</span>] &gt; prices[i]) &#123;</span><br><span class="line">                sum += prices[i + <span class="number">1</span>] - prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
            <category> leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【leetcode】598题解]]></title>
      <url>/2017/11/29/leetcode598/</url>
      <content type="html"><![CDATA[<p>Range Addition II</p>
<ul>
<li>题目描述：</li>
</ul>
<p>给出一个m*n的矩阵，值全为0，然后操作一个二维数组，来对矩阵进行改变，即每次数组中的[x,y]能够覆盖矩阵，即将覆盖的区域加1，返回矩阵中最大整数的个数</p>
<ul>
<li>样例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入：  </span><br><span class="line">m = 3，n = 3 </span><br><span class="line">操作= [[2,2]，[3,3]] 输出： 4</span><br><span class="line"> 说明： </span><br><span class="line">最初，M = </span><br><span class="line">[[0,0,0]，</span><br><span class="line"> [0,0,0]，</span><br><span class="line"> [0，0，0]] </span><br><span class="line">执行后[2,2]，M = </span><br><span class="line">[[1，1,0]，</span><br><span class="line"> [1,1，0]，</span><br><span class="line"> [0,0，0]] </span><br><span class="line">执行后[3,3] ，M = </span><br><span class="line">[[2,2,1]，</span><br><span class="line"> [2,2,1]，</span><br><span class="line"> [1,1,1]] </span><br><span class="line">所以M中的最大整数是2，M中有四个。所以返回4。</span><br></pre></td></tr></table></figure>
<ul>
<li>题解：</li>
</ul>
<p>这道题一上来思路就是要去找覆盖的地方，而覆盖的地方有什么特点呢？</p>
<p>1，肯定是一个比操作它的区域要小的区域<br>2，为最大整数，因为每次都会被覆盖，覆盖即加1</p>
<p>所以求个数的问题其实就是求最小区域的面积，即每次将行列与操作数组的行列进行比较，取最小值，代码十分简单。</p>
<ul>
<li>code</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span>[][] ops)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ops.length; i++) &#123;</span><br><span class="line">            m = Math.min(m, ops[i][<span class="number">0</span>]);</span><br><span class="line">            n = Math.min(n, ops[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m * n;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
            <category> leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【leetcode】538题解]]></title>
      <url>/2017/11/28/leetcode538/</url>
      <content type="html"><![CDATA[<p>Convert BST to Greater Tree</p>
<ul>
<li>题目描述：</li>
</ul>
<p>将一颗二叉搜索树的每个比当前节点大的节点都与该节点求和，从而形成一颗更大的二叉树</p>
<ul>
<li>样例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">             5</span><br><span class="line">            / \</span><br><span class="line">           2  13</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">            18</span><br><span class="line">            / \</span><br><span class="line">          20  13</span><br></pre></td></tr></table></figure>
<ul>
<li>题解：</li>
</ul>
<p>由题意，我们可以得知是一颗二叉搜索树，而二叉搜索数又有什么特点呢？</p>
<p>1，左儿子一定小于根节点</p>
<p>2，右儿子一定大于根节点</p>
<p>所以我们可以推断出，最后一个右儿子节点一定是最大的，最后一个左儿子节点一定是最小的，所以我们可以从先对右儿子进行相加，然后依次与其他节点求和</p>
<ul>
<li>code</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    convert(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">convert</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(node ==<span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">convert(node.right);</span><br><span class="line">node.val+=sum;</span><br><span class="line"><span class="comment">// 存储节点的值，供下次递归时使用</span></span><br><span class="line">sum= node.val;</span><br><span class="line">convert(node.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
            <category> leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
